// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: marketdata.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///Тип операции со списком подписок.
public enum SubscriptionAction: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Статус подписки не определён.
  case unspecified // = 0

  ///Подписаться.
  case subscribe // = 1

  ///Отписаться.
  case unsubscribe // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .subscribe
    case 2: self = .unsubscribe
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .subscribe: return 1
    case .unsubscribe: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension SubscriptionAction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [SubscriptionAction] = [
    .unspecified,
    .subscribe,
    .unsubscribe,
  ]
}

#endif  // swift(>=4.2)

///Интервал свечи.
public enum SubscriptionInterval: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Интервал свечи не определён.
  case unspecified // = 0

  ///Минутные свечи.
  case oneMinute // = 1

  ///Пятиминутные свечи.
  case fiveMinutes // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .oneMinute
    case 2: self = .fiveMinutes
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .oneMinute: return 1
    case .fiveMinutes: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension SubscriptionInterval: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [SubscriptionInterval] = [
    .unspecified,
    .oneMinute,
    .fiveMinutes,
  ]
}

#endif  // swift(>=4.2)

///Результат подписки.
public enum SubscriptionStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Статус подписки не определён.
  case unspecified // = 0

  ///Успешно.
  case success // = 1

  ///Инструмент не найден.
  case instrumentNotFound // = 2

  ///Некорректный статус подписки, список возможных значений: [SubscriptionAction](https://tinkoff.github.io/investAPI/marketdata#subscriptionaction).
  case subscriptionActionIsInvalid // = 3

  ///Некорректная глубина стакана, доступные значения: 1, 10, 20, 30, 40, 50.
  case depthIsInvalid // = 4

  ///Некорректный интервал свечей, список возможных значений: [SubscriptionInterval](https://tinkoff.github.io/investAPI/marketdata#subscriptioninterval).
  case intervalIsInvalid // = 5

  ///Превышен лимит на общее количество подписок в рамках стрима, подробнее: [Лимитная политика](https://tinkoff.github.io/investAPI/limits/).
  case limitIsExceeded // = 6

  ///Внутренняя ошибка сервиса.
  case internalError // = 7

  ///Превышен лимит на количество запросов на подписки в течение установленного отрезка времени
  case tooManyRequests // = 8
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .success
    case 2: self = .instrumentNotFound
    case 3: self = .subscriptionActionIsInvalid
    case 4: self = .depthIsInvalid
    case 5: self = .intervalIsInvalid
    case 6: self = .limitIsExceeded
    case 7: self = .internalError
    case 8: self = .tooManyRequests
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .success: return 1
    case .instrumentNotFound: return 2
    case .subscriptionActionIsInvalid: return 3
    case .depthIsInvalid: return 4
    case .intervalIsInvalid: return 5
    case .limitIsExceeded: return 6
    case .internalError: return 7
    case .tooManyRequests: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension SubscriptionStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [SubscriptionStatus] = [
    .unspecified,
    .success,
    .instrumentNotFound,
    .subscriptionActionIsInvalid,
    .depthIsInvalid,
    .intervalIsInvalid,
    .limitIsExceeded,
    .internalError,
    .tooManyRequests,
  ]
}

#endif  // swift(>=4.2)

///Направление сделки.
public enum TradeDirection: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Направление сделки не определено.
  case unspecified // = 0

  ///Покупка.
  case buy // = 1

  ///Продажа.
  case sell // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .buy
    case 2: self = .sell
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .buy: return 1
    case .sell: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension TradeDirection: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [TradeDirection] = [
    .unspecified,
    .buy,
    .sell,
  ]
}

#endif  // swift(>=4.2)

///Интервал свечей.
public enum CandleInterval: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Интервал не определён.
  case unspecified // = 0

  ///1 минута.
  case candleInterval1Min // = 1

  ///5 минут.
  case candleInterval5Min // = 2

  ///15 минут.
  case candleInterval15Min // = 3

  ///1 час.
  case hour // = 4

  ///1 день.
  case day // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .candleInterval1Min
    case 2: self = .candleInterval5Min
    case 3: self = .candleInterval15Min
    case 4: self = .hour
    case 5: self = .day
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .candleInterval1Min: return 1
    case .candleInterval5Min: return 2
    case .candleInterval15Min: return 3
    case .hour: return 4
    case .day: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension CandleInterval: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [CandleInterval] = [
    .unspecified,
    .candleInterval1Min,
    .candleInterval5Min,
    .candleInterval15Min,
    .hour,
    .day,
  ]
}

#endif  // swift(>=4.2)

///Запрос подписки или отписки на определённые биржевые данные.
public struct MarketDataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: MarketDataRequest.OneOf_Payload? = nil

  ///Запрос подписки на свечи.
  public var subscribeCandlesRequest: SubscribeCandlesRequest {
    get {
      if case .subscribeCandlesRequest(let v)? = payload {return v}
      return SubscribeCandlesRequest()
    }
    set {payload = .subscribeCandlesRequest(newValue)}
  }

  ///Запрос подписки на стаканы.
  public var subscribeOrderBookRequest: SubscribeOrderBookRequest {
    get {
      if case .subscribeOrderBookRequest(let v)? = payload {return v}
      return SubscribeOrderBookRequest()
    }
    set {payload = .subscribeOrderBookRequest(newValue)}
  }

  ///Запрос подписки на ленту обезличенных сделок.
  public var subscribeTradesRequest: SubscribeTradesRequest {
    get {
      if case .subscribeTradesRequest(let v)? = payload {return v}
      return SubscribeTradesRequest()
    }
    set {payload = .subscribeTradesRequest(newValue)}
  }

  ///Запрос подписки на торговые статусы инструментов.
  public var subscribeInfoRequest: SubscribeInfoRequest {
    get {
      if case .subscribeInfoRequest(let v)? = payload {return v}
      return SubscribeInfoRequest()
    }
    set {payload = .subscribeInfoRequest(newValue)}
  }

  ///Запрос подписки на последние цены.
  public var subscribeLastPriceRequest: SubscribeLastPriceRequest {
    get {
      if case .subscribeLastPriceRequest(let v)? = payload {return v}
      return SubscribeLastPriceRequest()
    }
    set {payload = .subscribeLastPriceRequest(newValue)}
  }

  ///Запрос своих подписок.
  public var getMySubscriptions: GetMySubscriptions {
    get {
      if case .getMySubscriptions(let v)? = payload {return v}
      return GetMySubscriptions()
    }
    set {payload = .getMySubscriptions(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    ///Запрос подписки на свечи.
    case subscribeCandlesRequest(SubscribeCandlesRequest)
    ///Запрос подписки на стаканы.
    case subscribeOrderBookRequest(SubscribeOrderBookRequest)
    ///Запрос подписки на ленту обезличенных сделок.
    case subscribeTradesRequest(SubscribeTradesRequest)
    ///Запрос подписки на торговые статусы инструментов.
    case subscribeInfoRequest(SubscribeInfoRequest)
    ///Запрос подписки на последние цены.
    case subscribeLastPriceRequest(SubscribeLastPriceRequest)
    ///Запрос своих подписок.
    case getMySubscriptions(GetMySubscriptions)

  #if !swift(>=4.1)
    public static func ==(lhs: MarketDataRequest.OneOf_Payload, rhs: MarketDataRequest.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.subscribeCandlesRequest, .subscribeCandlesRequest): return {
        guard case .subscribeCandlesRequest(let l) = lhs, case .subscribeCandlesRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeOrderBookRequest, .subscribeOrderBookRequest): return {
        guard case .subscribeOrderBookRequest(let l) = lhs, case .subscribeOrderBookRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeTradesRequest, .subscribeTradesRequest): return {
        guard case .subscribeTradesRequest(let l) = lhs, case .subscribeTradesRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeInfoRequest, .subscribeInfoRequest): return {
        guard case .subscribeInfoRequest(let l) = lhs, case .subscribeInfoRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeLastPriceRequest, .subscribeLastPriceRequest): return {
        guard case .subscribeLastPriceRequest(let l) = lhs, case .subscribeLastPriceRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getMySubscriptions, .getMySubscriptions): return {
        guard case .getMySubscriptions(let l) = lhs, case .getMySubscriptions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct MarketDataServerSideStreamRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Запрос подписки на свечи.
  public var subscribeCandlesRequest: SubscribeCandlesRequest {
    get {return _subscribeCandlesRequest ?? SubscribeCandlesRequest()}
    set {_subscribeCandlesRequest = newValue}
  }
  /// Returns true if `subscribeCandlesRequest` has been explicitly set.
  public var hasSubscribeCandlesRequest: Bool {return self._subscribeCandlesRequest != nil}
  /// Clears the value of `subscribeCandlesRequest`. Subsequent reads from it will return its default value.
  public mutating func clearSubscribeCandlesRequest() {self._subscribeCandlesRequest = nil}

  ///Запрос подписки на стаканы.
  public var subscribeOrderBookRequest: SubscribeOrderBookRequest {
    get {return _subscribeOrderBookRequest ?? SubscribeOrderBookRequest()}
    set {_subscribeOrderBookRequest = newValue}
  }
  /// Returns true if `subscribeOrderBookRequest` has been explicitly set.
  public var hasSubscribeOrderBookRequest: Bool {return self._subscribeOrderBookRequest != nil}
  /// Clears the value of `subscribeOrderBookRequest`. Subsequent reads from it will return its default value.
  public mutating func clearSubscribeOrderBookRequest() {self._subscribeOrderBookRequest = nil}

  ///Запрос подписки на ленту обезличенных сделок.
  public var subscribeTradesRequest: SubscribeTradesRequest {
    get {return _subscribeTradesRequest ?? SubscribeTradesRequest()}
    set {_subscribeTradesRequest = newValue}
  }
  /// Returns true if `subscribeTradesRequest` has been explicitly set.
  public var hasSubscribeTradesRequest: Bool {return self._subscribeTradesRequest != nil}
  /// Clears the value of `subscribeTradesRequest`. Subsequent reads from it will return its default value.
  public mutating func clearSubscribeTradesRequest() {self._subscribeTradesRequest = nil}

  ///Запрос подписки на торговые статусы инструментов.
  public var subscribeInfoRequest: SubscribeInfoRequest {
    get {return _subscribeInfoRequest ?? SubscribeInfoRequest()}
    set {_subscribeInfoRequest = newValue}
  }
  /// Returns true if `subscribeInfoRequest` has been explicitly set.
  public var hasSubscribeInfoRequest: Bool {return self._subscribeInfoRequest != nil}
  /// Clears the value of `subscribeInfoRequest`. Subsequent reads from it will return its default value.
  public mutating func clearSubscribeInfoRequest() {self._subscribeInfoRequest = nil}

  ///Запрос подписки на последние цены.
  public var subscribeLastPriceRequest: SubscribeLastPriceRequest {
    get {return _subscribeLastPriceRequest ?? SubscribeLastPriceRequest()}
    set {_subscribeLastPriceRequest = newValue}
  }
  /// Returns true if `subscribeLastPriceRequest` has been explicitly set.
  public var hasSubscribeLastPriceRequest: Bool {return self._subscribeLastPriceRequest != nil}
  /// Clears the value of `subscribeLastPriceRequest`. Subsequent reads from it will return its default value.
  public mutating func clearSubscribeLastPriceRequest() {self._subscribeLastPriceRequest = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _subscribeCandlesRequest: SubscribeCandlesRequest? = nil
  fileprivate var _subscribeOrderBookRequest: SubscribeOrderBookRequest? = nil
  fileprivate var _subscribeTradesRequest: SubscribeTradesRequest? = nil
  fileprivate var _subscribeInfoRequest: SubscribeInfoRequest? = nil
  fileprivate var _subscribeLastPriceRequest: SubscribeLastPriceRequest? = nil
}

///Пакет биржевой информации по подписке.
public struct MarketDataResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: MarketDataResponse.OneOf_Payload? = nil

  ///Результат подписки на свечи.
  public var subscribeCandlesResponse: SubscribeCandlesResponse {
    get {
      if case .subscribeCandlesResponse(let v)? = payload {return v}
      return SubscribeCandlesResponse()
    }
    set {payload = .subscribeCandlesResponse(newValue)}
  }

  ///Результат подписки на стаканы.
  public var subscribeOrderBookResponse: SubscribeOrderBookResponse {
    get {
      if case .subscribeOrderBookResponse(let v)? = payload {return v}
      return SubscribeOrderBookResponse()
    }
    set {payload = .subscribeOrderBookResponse(newValue)}
  }

  ///Результат подписки на поток обезличенных сделок.
  public var subscribeTradesResponse: SubscribeTradesResponse {
    get {
      if case .subscribeTradesResponse(let v)? = payload {return v}
      return SubscribeTradesResponse()
    }
    set {payload = .subscribeTradesResponse(newValue)}
  }

  ///Результат подписки на торговые статусы инструментов.
  public var subscribeInfoResponse: SubscribeInfoResponse {
    get {
      if case .subscribeInfoResponse(let v)? = payload {return v}
      return SubscribeInfoResponse()
    }
    set {payload = .subscribeInfoResponse(newValue)}
  }

  ///Свеча.
  public var candle: Candle {
    get {
      if case .candle(let v)? = payload {return v}
      return Candle()
    }
    set {payload = .candle(newValue)}
  }

  ///Сделки.
  public var trade: Trade {
    get {
      if case .trade(let v)? = payload {return v}
      return Trade()
    }
    set {payload = .trade(newValue)}
  }

  ///Стакан.
  public var orderbook: OrderBook {
    get {
      if case .orderbook(let v)? = payload {return v}
      return OrderBook()
    }
    set {payload = .orderbook(newValue)}
  }

  ///Торговый статус.
  public var tradingStatus: TradingStatus {
    get {
      if case .tradingStatus(let v)? = payload {return v}
      return TradingStatus()
    }
    set {payload = .tradingStatus(newValue)}
  }

  ///Проверка активности стрима.
  public var ping: Ping {
    get {
      if case .ping(let v)? = payload {return v}
      return Ping()
    }
    set {payload = .ping(newValue)}
  }

  ///Результат подписки на последние цены инструментов.
  public var subscribeLastPriceResponse: SubscribeLastPriceResponse {
    get {
      if case .subscribeLastPriceResponse(let v)? = payload {return v}
      return SubscribeLastPriceResponse()
    }
    set {payload = .subscribeLastPriceResponse(newValue)}
  }

  ///Последняя цена.
  public var lastPrice: LastPrice {
    get {
      if case .lastPrice(let v)? = payload {return v}
      return LastPrice()
    }
    set {payload = .lastPrice(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    ///Результат подписки на свечи.
    case subscribeCandlesResponse(SubscribeCandlesResponse)
    ///Результат подписки на стаканы.
    case subscribeOrderBookResponse(SubscribeOrderBookResponse)
    ///Результат подписки на поток обезличенных сделок.
    case subscribeTradesResponse(SubscribeTradesResponse)
    ///Результат подписки на торговые статусы инструментов.
    case subscribeInfoResponse(SubscribeInfoResponse)
    ///Свеча.
    case candle(Candle)
    ///Сделки.
    case trade(Trade)
    ///Стакан.
    case orderbook(OrderBook)
    ///Торговый статус.
    case tradingStatus(TradingStatus)
    ///Проверка активности стрима.
    case ping(Ping)
    ///Результат подписки на последние цены инструментов.
    case subscribeLastPriceResponse(SubscribeLastPriceResponse)
    ///Последняя цена.
    case lastPrice(LastPrice)

  #if !swift(>=4.1)
    public static func ==(lhs: MarketDataResponse.OneOf_Payload, rhs: MarketDataResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.subscribeCandlesResponse, .subscribeCandlesResponse): return {
        guard case .subscribeCandlesResponse(let l) = lhs, case .subscribeCandlesResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeOrderBookResponse, .subscribeOrderBookResponse): return {
        guard case .subscribeOrderBookResponse(let l) = lhs, case .subscribeOrderBookResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeTradesResponse, .subscribeTradesResponse): return {
        guard case .subscribeTradesResponse(let l) = lhs, case .subscribeTradesResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeInfoResponse, .subscribeInfoResponse): return {
        guard case .subscribeInfoResponse(let l) = lhs, case .subscribeInfoResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.candle, .candle): return {
        guard case .candle(let l) = lhs, case .candle(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.trade, .trade): return {
        guard case .trade(let l) = lhs, case .trade(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.orderbook, .orderbook): return {
        guard case .orderbook(let l) = lhs, case .orderbook(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tradingStatus, .tradingStatus): return {
        guard case .tradingStatus(let l) = lhs, case .tradingStatus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ping, .ping): return {
        guard case .ping(let l) = lhs, case .ping(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeLastPriceResponse, .subscribeLastPriceResponse): return {
        guard case .subscribeLastPriceResponse(let l) = lhs, case .subscribeLastPriceResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.lastPrice, .lastPrice): return {
        guard case .lastPrice(let l) = lhs, case .lastPrice(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// subscribeCandles | Изменения статуса подписки на свечи.
public struct SubscribeCandlesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Изменение статуса подписки.
  public var subscriptionAction: SubscriptionAction = .unspecified

  ///Массив инструментов для подписки на свечи.
  public var instruments: [CandleInstrument] = []

  ///Флаг ожидания закрытия временного интервала для отправки свечи, применяется только для минутных свечей.
  public var waitingClose: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос изменения статус подписки на свечи.
public struct CandleInstrument {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Интервал свечей.
  public var interval: SubscriptionInterval = .unspecified

  ///Идентификатор инструмента, принимает значение figi или instrument_uid
  public var instrumentID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Результат изменения статус подписки на свечи.
public struct SubscribeCandlesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Уникальный идентификатор запроса, подробнее: [tracking_id](https://tinkoff.github.io/investAPI/grpc#tracking-id).
  public var trackingID: String = String()

  ///Массив статусов подписки на свечи.
  public var candlesSubscriptions: [CandleSubscription] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Статус подписки на свечи.
public struct CandleSubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Интервал свечей.
  public var interval: SubscriptionInterval = .unspecified

  ///Статус подписки.
  public var subscriptionStatus: SubscriptionStatus = .unspecified

  ///Uid инструмента
  public var instrumentUid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос на изменение статуса подписки на стаканы.
public struct SubscribeOrderBookRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Изменение статуса подписки.
  public var subscriptionAction: SubscriptionAction = .unspecified

  ///Массив инструментов для подписки на стаканы.
  public var instruments: [OrderBookInstrument] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос подписки на стаканы.
public struct OrderBookInstrument {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Глубина стакана.
  public var depth: Int32 = 0

  ///Идентификатор инструмента, принимает значение figi или instrument_uid
  public var instrumentID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Результат изменения статуса подписки на стаканы.
public struct SubscribeOrderBookResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Уникальный идентификатор запроса, подробнее: [tracking_id](https://tinkoff.github.io/investAPI/grpc#tracking-id).
  public var trackingID: String = String()

  ///Массив статусов подписки на стаканы.
  public var orderBookSubscriptions: [OrderBookSubscription] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Статус подписки.
public struct OrderBookSubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Глубина стакана.
  public var depth: Int32 = 0

  ///Статус подписки.
  public var subscriptionStatus: SubscriptionStatus = .unspecified

  ///Uid инструмента
  public var instrumentUid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Изменение статуса подписки на поток обезличенных сделок.
public struct SubscribeTradesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Изменение статуса подписки.
  public var subscriptionAction: SubscriptionAction = .unspecified

  ///Массив инструментов для подписки на поток обезличенных сделок.
  public var instruments: [TradeInstrument] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос подписки на поток обезличенных сделок.
public struct TradeInstrument {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Идентификатор инструмента, принимает значение figi или instrument_uid
  public var instrumentID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Результат изменения статуса подписки на поток обезличенных сделок.
public struct SubscribeTradesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Уникальный идентификатор запроса, подробнее: [tracking_id](https://tinkoff.github.io/investAPI/grpc#tracking-id).
  public var trackingID: String = String()

  ///Массив статусов подписки на поток сделок.
  public var tradeSubscriptions: [TradeSubscription] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Статус подписки.
public struct TradeSubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Статус подписки.
  public var subscriptionStatus: SubscriptionStatus = .unspecified

  ///Uid инструмента
  public var instrumentUid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Изменение статуса подписки на торговый статус инструмента.
public struct SubscribeInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Изменение статуса подписки.
  public var subscriptionAction: SubscriptionAction = .unspecified

  ///Массив инструментов для подписки на торговый статус.
  public var instruments: [InfoInstrument] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос подписки на торговый статус.
public struct InfoInstrument {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Идентификатор инструмента, принимает значение figi или instrument_uid
  public var instrumentID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Результат изменения статуса подписки на торговый статус.
public struct SubscribeInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Уникальный идентификатор запроса, подробнее: [tracking_id](https://tinkoff.github.io/investAPI/grpc#tracking-id).
  public var trackingID: String = String()

  ///Массив статусов подписки на торговый статус.
  public var infoSubscriptions: [InfoSubscription] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Статус подписки.
public struct InfoSubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Статус подписки.
  public var subscriptionStatus: SubscriptionStatus = .unspecified

  ///Uid инструмента
  public var instrumentUid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Изменение статуса подписки на последнюю цену инструмента.
public struct SubscribeLastPriceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Изменение статуса подписки.
  public var subscriptionAction: SubscriptionAction = .unspecified

  ///Массив инструментов для подписки на последнюю цену.
  public var instruments: [LastPriceInstrument] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос подписки на последнюю цену.
public struct LastPriceInstrument {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Идентификатор инструмента, принимает значение figi или instrument_uid
  public var instrumentID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Результат изменения статуса подписки на последнюю цену.
public struct SubscribeLastPriceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Уникальный идентификатор запроса, подробнее: [tracking_id](https://tinkoff.github.io/investAPI/grpc#tracking-id).
  public var trackingID: String = String()

  ///Массив статусов подписки на последнюю цену.
  public var lastPriceSubscriptions: [LastPriceSubscription] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Статус подписки на последнюю цену.
public struct LastPriceSubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Статус подписки.
  public var subscriptionStatus: SubscriptionStatus = .unspecified

  ///Uid инструмента
  public var instrumentUid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Пакет свечей в рамках стрима.
public struct Candle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Интервал свечи.
  public var interval: SubscriptionInterval = .unspecified

  ///Цена открытия за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
  public var `open`: Quotation {
    get {return _open ?? Quotation()}
    set {_open = newValue}
  }
  /// Returns true if ``open`` has been explicitly set.
  public var hasOpen: Bool {return self._open != nil}
  /// Clears the value of ``open``. Subsequent reads from it will return its default value.
  public mutating func clearOpen() {self._open = nil}

  ///Максимальная цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
  public var high: Quotation {
    get {return _high ?? Quotation()}
    set {_high = newValue}
  }
  /// Returns true if `high` has been explicitly set.
  public var hasHigh: Bool {return self._high != nil}
  /// Clears the value of `high`. Subsequent reads from it will return its default value.
  public mutating func clearHigh() {self._high = nil}

  ///Минимальная цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
  public var low: Quotation {
    get {return _low ?? Quotation()}
    set {_low = newValue}
  }
  /// Returns true if `low` has been explicitly set.
  public var hasLow: Bool {return self._low != nil}
  /// Clears the value of `low`. Subsequent reads from it will return its default value.
  public mutating func clearLow() {self._low = nil}

  ///Цена закрытия за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
  public var close: Quotation {
    get {return _close ?? Quotation()}
    set {_close = newValue}
  }
  /// Returns true if `close` has been explicitly set.
  public var hasClose: Bool {return self._close != nil}
  /// Clears the value of `close`. Subsequent reads from it will return its default value.
  public mutating func clearClose() {self._close = nil}

  ///Объём сделок в лотах.
  public var volume: Int64 = 0

  ///Время начала интервала свечи в часовом поясе UTC.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  ///Время последней сделки, вошедшей в свечу в часовом поясе UTC.
  public var lastTradeTs: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastTradeTs ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastTradeTs = newValue}
  }
  /// Returns true if `lastTradeTs` has been explicitly set.
  public var hasLastTradeTs: Bool {return self._lastTradeTs != nil}
  /// Clears the value of `lastTradeTs`. Subsequent reads from it will return its default value.
  public mutating func clearLastTradeTs() {self._lastTradeTs = nil}

  ///Uid инструмента
  public var instrumentUid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _open: Quotation? = nil
  fileprivate var _high: Quotation? = nil
  fileprivate var _low: Quotation? = nil
  fileprivate var _close: Quotation? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _lastTradeTs: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Пакет стаканов в рамках стрима.
public struct OrderBook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Глубина стакана.
  public var depth: Int32 = 0

  ///Флаг консистентности стакана. **false** значит не все заявки попали в стакан по причинам сетевых задержек или нарушения порядка доставки.
  public var isConsistent: Bool = false

  ///Массив предложений.
  public var bids: [Order] = []

  ///Массив спроса.
  public var asks: [Order] = []

  ///Время формирования стакана в часовом поясе UTC по времени биржи.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  ///Верхний лимит цены за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
  public var limitUp: Quotation {
    get {return _limitUp ?? Quotation()}
    set {_limitUp = newValue}
  }
  /// Returns true if `limitUp` has been explicitly set.
  public var hasLimitUp: Bool {return self._limitUp != nil}
  /// Clears the value of `limitUp`. Subsequent reads from it will return its default value.
  public mutating func clearLimitUp() {self._limitUp = nil}

  ///Нижний лимит цены за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
  public var limitDown: Quotation {
    get {return _limitDown ?? Quotation()}
    set {_limitDown = newValue}
  }
  /// Returns true if `limitDown` has been explicitly set.
  public var hasLimitDown: Bool {return self._limitDown != nil}
  /// Clears the value of `limitDown`. Subsequent reads from it will return its default value.
  public mutating func clearLimitDown() {self._limitDown = nil}

  ///Uid инструмента
  public var instrumentUid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _limitUp: Quotation? = nil
  fileprivate var _limitDown: Quotation? = nil
}

///Массив предложений/спроса.
public struct Order {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
  public var price: Quotation {
    get {return _price ?? Quotation()}
    set {_price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  public var hasPrice: Bool {return self._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  public mutating func clearPrice() {self._price = nil}

  ///Количество в лотах.
  public var quantity: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _price: Quotation? = nil
}

///Информация о сделке.
public struct Trade {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Направление сделки.
  public var direction: TradeDirection = .unspecified

  ///Цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
  public var price: Quotation {
    get {return _price ?? Quotation()}
    set {_price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  public var hasPrice: Bool {return self._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  public mutating func clearPrice() {self._price = nil}

  ///Количество лотов.
  public var quantity: Int64 = 0

  ///Время сделки в часовом поясе UTC по времени биржи.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  ///Uid инструмента
  public var instrumentUid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _price: Quotation? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Пакет изменения торгового статуса.
public struct TradingStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Статус торговли инструментом.
  public var tradingStatus: SecurityTradingStatus = .unspecified

  ///Время изменения торгового статуса в часовом поясе UTC.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  ///Признак доступности выставления лимитной заявки по инструменту.
  public var limitOrderAvailableFlag: Bool = false

  ///Признак доступности выставления рыночной заявки по инструменту.
  public var marketOrderAvailableFlag: Bool = false

  ///Uid инструмента
  public var instrumentUid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Запрос исторических свечей.
public struct GetCandlesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Начало запрашиваемого периода в часовом поясе UTC.
  public var from: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  public var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  public mutating func clearFrom() {self._from = nil}

  ///Окончание запрашиваемого периода в часовом поясе UTC.
  public var to: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  public var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  public mutating func clearTo() {self._to = nil}

  ///Интервал запрошенных свечей.
  public var interval: CandleInterval = .unspecified

  ///Идентификатор инструмента, принимает значение figi или instrument_uid
  public var instrumentID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Список свечей.
public struct GetCandlesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив свечей.
  public var candles: [HistoricCandle] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Информация о свече.
public struct HistoricCandle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Цена открытия за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
  public var `open`: Quotation {
    get {return _open ?? Quotation()}
    set {_open = newValue}
  }
  /// Returns true if ``open`` has been explicitly set.
  public var hasOpen: Bool {return self._open != nil}
  /// Clears the value of ``open``. Subsequent reads from it will return its default value.
  public mutating func clearOpen() {self._open = nil}

  ///Максимальная цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
  public var high: Quotation {
    get {return _high ?? Quotation()}
    set {_high = newValue}
  }
  /// Returns true if `high` has been explicitly set.
  public var hasHigh: Bool {return self._high != nil}
  /// Clears the value of `high`. Subsequent reads from it will return its default value.
  public mutating func clearHigh() {self._high = nil}

  ///Минимальная цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
  public var low: Quotation {
    get {return _low ?? Quotation()}
    set {_low = newValue}
  }
  /// Returns true if `low` has been explicitly set.
  public var hasLow: Bool {return self._low != nil}
  /// Clears the value of `low`. Subsequent reads from it will return its default value.
  public mutating func clearLow() {self._low = nil}

  ///Цена закрытия за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
  public var close: Quotation {
    get {return _close ?? Quotation()}
    set {_close = newValue}
  }
  /// Returns true if `close` has been explicitly set.
  public var hasClose: Bool {return self._close != nil}
  /// Clears the value of `close`. Subsequent reads from it will return its default value.
  public mutating func clearClose() {self._close = nil}

  ///Объём торгов в лотах.
  public var volume: Int64 = 0

  ///Время свечи в часовом поясе UTC.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  ///Признак завершённости свечи. **false** значит, свеча за текущие интервал ещё сформирована не полностью.
  public var isComplete: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _open: Quotation? = nil
  fileprivate var _high: Quotation? = nil
  fileprivate var _low: Quotation? = nil
  fileprivate var _close: Quotation? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Запрос получения последних цен.
public struct GetLastPricesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив figi-идентификаторов инструментов.
  public var figi: [String] = []

  ///Массив идентификаторов инструмента, принимает значения figi или instrument_uid
  public var instrumentID: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Список последних цен.
public struct GetLastPricesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив последних цен.
  public var lastPrices: [LastPrice] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Информация о цене.
public struct LastPrice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi инструмента.
  public var figi: String = String()

  ///Последняя цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
  public var price: Quotation {
    get {return _price ?? Quotation()}
    set {_price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  public var hasPrice: Bool {return self._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  public mutating func clearPrice() {self._price = nil}

  ///Время получения последней цены в часовом поясе UTC по времени биржи.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  ///Uid инструмента
  public var instrumentUid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _price: Quotation? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Запрос стакана.
public struct GetOrderBookRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Глубина стакана.
  public var depth: Int32 = 0

  ///Идентификатор инструмента, принимает значение figi или instrument_uid
  public var instrumentID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Информация о стакане.
public struct GetOrderBookResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String {
    get {return _storage._figi}
    set {_uniqueStorage()._figi = newValue}
  }

  ///Глубина стакана.
  public var depth: Int32 {
    get {return _storage._depth}
    set {_uniqueStorage()._depth = newValue}
  }

  ///Множество пар значений на покупку.
  public var bids: [Order] {
    get {return _storage._bids}
    set {_uniqueStorage()._bids = newValue}
  }

  ///Множество пар значений на продажу.
  public var asks: [Order] {
    get {return _storage._asks}
    set {_uniqueStorage()._asks = newValue}
  }

  ///Цена последней сделки за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
  public var lastPrice: Quotation {
    get {return _storage._lastPrice ?? Quotation()}
    set {_uniqueStorage()._lastPrice = newValue}
  }
  /// Returns true if `lastPrice` has been explicitly set.
  public var hasLastPrice: Bool {return _storage._lastPrice != nil}
  /// Clears the value of `lastPrice`. Subsequent reads from it will return its default value.
  public mutating func clearLastPrice() {_uniqueStorage()._lastPrice = nil}

  ///Цена закрытия за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
  public var closePrice: Quotation {
    get {return _storage._closePrice ?? Quotation()}
    set {_uniqueStorage()._closePrice = newValue}
  }
  /// Returns true if `closePrice` has been explicitly set.
  public var hasClosePrice: Bool {return _storage._closePrice != nil}
  /// Clears the value of `closePrice`. Subsequent reads from it will return its default value.
  public mutating func clearClosePrice() {_uniqueStorage()._closePrice = nil}

  ///Верхний лимит цены за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
  public var limitUp: Quotation {
    get {return _storage._limitUp ?? Quotation()}
    set {_uniqueStorage()._limitUp = newValue}
  }
  /// Returns true if `limitUp` has been explicitly set.
  public var hasLimitUp: Bool {return _storage._limitUp != nil}
  /// Clears the value of `limitUp`. Subsequent reads from it will return its default value.
  public mutating func clearLimitUp() {_uniqueStorage()._limitUp = nil}

  ///Нижний лимит цены за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
  public var limitDown: Quotation {
    get {return _storage._limitDown ?? Quotation()}
    set {_uniqueStorage()._limitDown = newValue}
  }
  /// Returns true if `limitDown` has been explicitly set.
  public var hasLimitDown: Bool {return _storage._limitDown != nil}
  /// Clears the value of `limitDown`. Subsequent reads from it will return its default value.
  public mutating func clearLimitDown() {_uniqueStorage()._limitDown = nil}

  ///Время получения цены последней сделки.
  public var lastPriceTs: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastPriceTs ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastPriceTs = newValue}
  }
  /// Returns true if `lastPriceTs` has been explicitly set.
  public var hasLastPriceTs: Bool {return _storage._lastPriceTs != nil}
  /// Clears the value of `lastPriceTs`. Subsequent reads from it will return its default value.
  public mutating func clearLastPriceTs() {_uniqueStorage()._lastPriceTs = nil}

  ///Время получения цены закрытия.
  public var closePriceTs: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._closePriceTs ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._closePriceTs = newValue}
  }
  /// Returns true if `closePriceTs` has been explicitly set.
  public var hasClosePriceTs: Bool {return _storage._closePriceTs != nil}
  /// Clears the value of `closePriceTs`. Subsequent reads from it will return its default value.
  public mutating func clearClosePriceTs() {_uniqueStorage()._closePriceTs = nil}

  ///Время формирования стакана на бирже.
  public var orderbookTs: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._orderbookTs ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._orderbookTs = newValue}
  }
  /// Returns true if `orderbookTs` has been explicitly set.
  public var hasOrderbookTs: Bool {return _storage._orderbookTs != nil}
  /// Clears the value of `orderbookTs`. Subsequent reads from it will return its default value.
  public mutating func clearOrderbookTs() {_uniqueStorage()._orderbookTs = nil}

  ///Uid инструмента
  public var instrumentUid: String {
    get {return _storage._instrumentUid}
    set {_uniqueStorage()._instrumentUid = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Запрос получения торгового статуса.
public struct GetTradingStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор инструмента.
  public var figi: String = String()

  ///Идентификатор инструмента, принимает значение figi или instrument_uid
  public var instrumentID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Информация о торговом статусе.
public struct GetTradingStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Статус торговли инструментом.
  public var tradingStatus: SecurityTradingStatus = .unspecified

  ///Признак доступности выставления лимитной заявки по инструменту.
  public var limitOrderAvailableFlag: Bool = false

  ///Признак доступности выставления рыночной заявки по инструменту.
  public var marketOrderAvailableFlag: Bool = false

  ///Признак доступности торгов через API.
  public var apiTradeAvailableFlag: Bool = false

  ///Uid инструмента
  public var instrumentUid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос обезличенных сделок за последний час.
public struct GetLastTradesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента
  public var figi: String = String()

  ///Начало запрашиваемого периода в часовом поясе UTC.
  public var from: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  public var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  public mutating func clearFrom() {self._from = nil}

  ///Окончание запрашиваемого периода в часовом поясе UTC.
  public var to: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  public var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  public mutating func clearTo() {self._to = nil}

  ///Идентификатор инструмента, принимает значение figi или instrument_uid
  public var instrumentID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Обезличенных сделок за последний час.
public struct GetLastTradesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив сделок
  public var trades: [Trade] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос активных подписок.
public struct GetMySubscriptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос цен закрытия торговой сессии по инструментам.
public struct GetClosePricesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив по инструментам.
  public var instruments: [InstrumentClosePriceRequest] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос цен закрытия торговой сессии по инструменту.
public struct InstrumentClosePriceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор инструмента, принимает значение figi или instrument_uid
  public var instrumentID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Цены закрытия торговой сессии по инструментам.
public struct GetClosePricesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив по инструментам.
  public var closePrices: [InstrumentClosePriceResponse] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Цена закрытия торговой сессии по инструменту.
public struct InstrumentClosePriceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi инструмента.
  public var figi: String = String()

  ///Uid инструмента.
  public var instrumentUid: String = String()

  ///Цена закрытия торговой сессии.
  public var price: Quotation {
    get {return _price ?? Quotation()}
    set {_price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  public var hasPrice: Bool {return self._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  public mutating func clearPrice() {self._price = nil}

  ///Дата совершения торгов.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _price: Quotation? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tinkoff.public.invest.api.contract.v1"

extension SubscriptionAction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUBSCRIPTION_ACTION_UNSPECIFIED"),
    1: .same(proto: "SUBSCRIPTION_ACTION_SUBSCRIBE"),
    2: .same(proto: "SUBSCRIPTION_ACTION_UNSUBSCRIBE"),
  ]
}

extension SubscriptionInterval: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUBSCRIPTION_INTERVAL_UNSPECIFIED"),
    1: .same(proto: "SUBSCRIPTION_INTERVAL_ONE_MINUTE"),
    2: .same(proto: "SUBSCRIPTION_INTERVAL_FIVE_MINUTES"),
  ]
}

extension SubscriptionStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUBSCRIPTION_STATUS_UNSPECIFIED"),
    1: .same(proto: "SUBSCRIPTION_STATUS_SUCCESS"),
    2: .same(proto: "SUBSCRIPTION_STATUS_INSTRUMENT_NOT_FOUND"),
    3: .same(proto: "SUBSCRIPTION_STATUS_SUBSCRIPTION_ACTION_IS_INVALID"),
    4: .same(proto: "SUBSCRIPTION_STATUS_DEPTH_IS_INVALID"),
    5: .same(proto: "SUBSCRIPTION_STATUS_INTERVAL_IS_INVALID"),
    6: .same(proto: "SUBSCRIPTION_STATUS_LIMIT_IS_EXCEEDED"),
    7: .same(proto: "SUBSCRIPTION_STATUS_INTERNAL_ERROR"),
    8: .same(proto: "SUBSCRIPTION_STATUS_TOO_MANY_REQUESTS"),
  ]
}

extension TradeDirection: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRADE_DIRECTION_UNSPECIFIED"),
    1: .same(proto: "TRADE_DIRECTION_BUY"),
    2: .same(proto: "TRADE_DIRECTION_SELL"),
  ]
}

extension CandleInterval: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CANDLE_INTERVAL_UNSPECIFIED"),
    1: .same(proto: "CANDLE_INTERVAL_1_MIN"),
    2: .same(proto: "CANDLE_INTERVAL_5_MIN"),
    3: .same(proto: "CANDLE_INTERVAL_15_MIN"),
    4: .same(proto: "CANDLE_INTERVAL_HOUR"),
    5: .same(proto: "CANDLE_INTERVAL_DAY"),
  ]
}

extension MarketDataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MarketDataRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscribe_candles_request"),
    2: .standard(proto: "subscribe_order_book_request"),
    3: .standard(proto: "subscribe_trades_request"),
    4: .standard(proto: "subscribe_info_request"),
    5: .standard(proto: "subscribe_last_price_request"),
    6: .standard(proto: "get_my_subscriptions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: SubscribeCandlesRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeCandlesRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeCandlesRequest(v)
        }
      }()
      case 2: try {
        var v: SubscribeOrderBookRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeOrderBookRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeOrderBookRequest(v)
        }
      }()
      case 3: try {
        var v: SubscribeTradesRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeTradesRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeTradesRequest(v)
        }
      }()
      case 4: try {
        var v: SubscribeInfoRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeInfoRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeInfoRequest(v)
        }
      }()
      case 5: try {
        var v: SubscribeLastPriceRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeLastPriceRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeLastPriceRequest(v)
        }
      }()
      case 6: try {
        var v: GetMySubscriptions?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .getMySubscriptions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .getMySubscriptions(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .subscribeCandlesRequest?: try {
      guard case .subscribeCandlesRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .subscribeOrderBookRequest?: try {
      guard case .subscribeOrderBookRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .subscribeTradesRequest?: try {
      guard case .subscribeTradesRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .subscribeInfoRequest?: try {
      guard case .subscribeInfoRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .subscribeLastPriceRequest?: try {
      guard case .subscribeLastPriceRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .getMySubscriptions?: try {
      guard case .getMySubscriptions(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MarketDataRequest, rhs: MarketDataRequest) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MarketDataServerSideStreamRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MarketDataServerSideStreamRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscribe_candles_request"),
    2: .standard(proto: "subscribe_order_book_request"),
    3: .standard(proto: "subscribe_trades_request"),
    4: .standard(proto: "subscribe_info_request"),
    5: .standard(proto: "subscribe_last_price_request"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._subscribeCandlesRequest) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._subscribeOrderBookRequest) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._subscribeTradesRequest) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._subscribeInfoRequest) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._subscribeLastPriceRequest) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._subscribeCandlesRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._subscribeOrderBookRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._subscribeTradesRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._subscribeInfoRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._subscribeLastPriceRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MarketDataServerSideStreamRequest, rhs: MarketDataServerSideStreamRequest) -> Bool {
    if lhs._subscribeCandlesRequest != rhs._subscribeCandlesRequest {return false}
    if lhs._subscribeOrderBookRequest != rhs._subscribeOrderBookRequest {return false}
    if lhs._subscribeTradesRequest != rhs._subscribeTradesRequest {return false}
    if lhs._subscribeInfoRequest != rhs._subscribeInfoRequest {return false}
    if lhs._subscribeLastPriceRequest != rhs._subscribeLastPriceRequest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MarketDataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MarketDataResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscribe_candles_response"),
    2: .standard(proto: "subscribe_order_book_response"),
    3: .standard(proto: "subscribe_trades_response"),
    4: .standard(proto: "subscribe_info_response"),
    5: .same(proto: "candle"),
    6: .same(proto: "trade"),
    7: .same(proto: "orderbook"),
    8: .standard(proto: "trading_status"),
    9: .same(proto: "ping"),
    10: .standard(proto: "subscribe_last_price_response"),
    11: .standard(proto: "last_price"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: SubscribeCandlesResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeCandlesResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeCandlesResponse(v)
        }
      }()
      case 2: try {
        var v: SubscribeOrderBookResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeOrderBookResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeOrderBookResponse(v)
        }
      }()
      case 3: try {
        var v: SubscribeTradesResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeTradesResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeTradesResponse(v)
        }
      }()
      case 4: try {
        var v: SubscribeInfoResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeInfoResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeInfoResponse(v)
        }
      }()
      case 5: try {
        var v: Candle?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .candle(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .candle(v)
        }
      }()
      case 6: try {
        var v: Trade?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .trade(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .trade(v)
        }
      }()
      case 7: try {
        var v: OrderBook?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .orderbook(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .orderbook(v)
        }
      }()
      case 8: try {
        var v: TradingStatus?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .tradingStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .tradingStatus(v)
        }
      }()
      case 9: try {
        var v: Ping?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .ping(v)
        }
      }()
      case 10: try {
        var v: SubscribeLastPriceResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeLastPriceResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeLastPriceResponse(v)
        }
      }()
      case 11: try {
        var v: LastPrice?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .lastPrice(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .lastPrice(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .subscribeCandlesResponse?: try {
      guard case .subscribeCandlesResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .subscribeOrderBookResponse?: try {
      guard case .subscribeOrderBookResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .subscribeTradesResponse?: try {
      guard case .subscribeTradesResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .subscribeInfoResponse?: try {
      guard case .subscribeInfoResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .candle?: try {
      guard case .candle(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .trade?: try {
      guard case .trade(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .orderbook?: try {
      guard case .orderbook(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .tradingStatus?: try {
      guard case .tradingStatus(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .ping?: try {
      guard case .ping(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .subscribeLastPriceResponse?: try {
      guard case .subscribeLastPriceResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .lastPrice?: try {
      guard case .lastPrice(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MarketDataResponse, rhs: MarketDataResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeCandlesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeCandlesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_action"),
    2: .same(proto: "instruments"),
    3: .standard(proto: "waiting_close"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.subscriptionAction) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.waitingClose) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.subscriptionAction != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionAction, fieldNumber: 1)
    }
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 2)
    }
    if self.waitingClose != false {
      try visitor.visitSingularBoolField(value: self.waitingClose, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubscribeCandlesRequest, rhs: SubscribeCandlesRequest) -> Bool {
    if lhs.subscriptionAction != rhs.subscriptionAction {return false}
    if lhs.instruments != rhs.instruments {return false}
    if lhs.waitingClose != rhs.waitingClose {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CandleInstrument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CandleInstrument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "interval"),
    3: .standard(proto: "instrument_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.interval) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.interval != .unspecified {
      try visitor.visitSingularEnumField(value: self.interval, fieldNumber: 2)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CandleInstrument, rhs: CandleInstrument) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.interval != rhs.interval {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeCandlesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeCandlesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tracking_id"),
    2: .standard(proto: "candles_subscriptions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trackingID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.candlesSubscriptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trackingID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackingID, fieldNumber: 1)
    }
    if !self.candlesSubscriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.candlesSubscriptions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubscribeCandlesResponse, rhs: SubscribeCandlesResponse) -> Bool {
    if lhs.trackingID != rhs.trackingID {return false}
    if lhs.candlesSubscriptions != rhs.candlesSubscriptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CandleSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CandleSubscription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "interval"),
    3: .standard(proto: "subscription_status"),
    4: .standard(proto: "instrument_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.interval) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.subscriptionStatus) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.interval != .unspecified {
      try visitor.visitSingularEnumField(value: self.interval, fieldNumber: 2)
    }
    if self.subscriptionStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionStatus, fieldNumber: 3)
    }
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CandleSubscription, rhs: CandleSubscription) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.interval != rhs.interval {return false}
    if lhs.subscriptionStatus != rhs.subscriptionStatus {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeOrderBookRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeOrderBookRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_action"),
    2: .same(proto: "instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.subscriptionAction) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.subscriptionAction != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionAction, fieldNumber: 1)
    }
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubscribeOrderBookRequest, rhs: SubscribeOrderBookRequest) -> Bool {
    if lhs.subscriptionAction != rhs.subscriptionAction {return false}
    if lhs.instruments != rhs.instruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OrderBookInstrument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OrderBookInstrument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "depth"),
    3: .standard(proto: "instrument_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.depth) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.depth != 0 {
      try visitor.visitSingularInt32Field(value: self.depth, fieldNumber: 2)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OrderBookInstrument, rhs: OrderBookInstrument) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.depth != rhs.depth {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeOrderBookResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeOrderBookResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tracking_id"),
    2: .standard(proto: "order_book_subscriptions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trackingID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.orderBookSubscriptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trackingID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackingID, fieldNumber: 1)
    }
    if !self.orderBookSubscriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orderBookSubscriptions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubscribeOrderBookResponse, rhs: SubscribeOrderBookResponse) -> Bool {
    if lhs.trackingID != rhs.trackingID {return false}
    if lhs.orderBookSubscriptions != rhs.orderBookSubscriptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OrderBookSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OrderBookSubscription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "depth"),
    3: .standard(proto: "subscription_status"),
    4: .standard(proto: "instrument_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.depth) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.subscriptionStatus) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.depth != 0 {
      try visitor.visitSingularInt32Field(value: self.depth, fieldNumber: 2)
    }
    if self.subscriptionStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionStatus, fieldNumber: 3)
    }
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OrderBookSubscription, rhs: OrderBookSubscription) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.depth != rhs.depth {return false}
    if lhs.subscriptionStatus != rhs.subscriptionStatus {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeTradesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeTradesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_action"),
    2: .same(proto: "instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.subscriptionAction) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.subscriptionAction != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionAction, fieldNumber: 1)
    }
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubscribeTradesRequest, rhs: SubscribeTradesRequest) -> Bool {
    if lhs.subscriptionAction != rhs.subscriptionAction {return false}
    if lhs.instruments != rhs.instruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TradeInstrument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TradeInstrument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "instrument_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TradeInstrument, rhs: TradeInstrument) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeTradesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeTradesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tracking_id"),
    2: .standard(proto: "trade_subscriptions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trackingID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tradeSubscriptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trackingID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackingID, fieldNumber: 1)
    }
    if !self.tradeSubscriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tradeSubscriptions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubscribeTradesResponse, rhs: SubscribeTradesResponse) -> Bool {
    if lhs.trackingID != rhs.trackingID {return false}
    if lhs.tradeSubscriptions != rhs.tradeSubscriptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TradeSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TradeSubscription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "subscription_status"),
    3: .standard(proto: "instrument_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.subscriptionStatus) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.subscriptionStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionStatus, fieldNumber: 2)
    }
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TradeSubscription, rhs: TradeSubscription) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.subscriptionStatus != rhs.subscriptionStatus {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeInfoRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_action"),
    2: .same(proto: "instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.subscriptionAction) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.subscriptionAction != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionAction, fieldNumber: 1)
    }
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubscribeInfoRequest, rhs: SubscribeInfoRequest) -> Bool {
    if lhs.subscriptionAction != rhs.subscriptionAction {return false}
    if lhs.instruments != rhs.instruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InfoInstrument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InfoInstrument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "instrument_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InfoInstrument, rhs: InfoInstrument) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeInfoResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tracking_id"),
    2: .standard(proto: "info_subscriptions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trackingID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.infoSubscriptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trackingID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackingID, fieldNumber: 1)
    }
    if !self.infoSubscriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.infoSubscriptions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubscribeInfoResponse, rhs: SubscribeInfoResponse) -> Bool {
    if lhs.trackingID != rhs.trackingID {return false}
    if lhs.infoSubscriptions != rhs.infoSubscriptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InfoSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InfoSubscription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "subscription_status"),
    3: .standard(proto: "instrument_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.subscriptionStatus) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.subscriptionStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionStatus, fieldNumber: 2)
    }
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InfoSubscription, rhs: InfoSubscription) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.subscriptionStatus != rhs.subscriptionStatus {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeLastPriceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeLastPriceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_action"),
    2: .same(proto: "instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.subscriptionAction) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.subscriptionAction != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionAction, fieldNumber: 1)
    }
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubscribeLastPriceRequest, rhs: SubscribeLastPriceRequest) -> Bool {
    if lhs.subscriptionAction != rhs.subscriptionAction {return false}
    if lhs.instruments != rhs.instruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LastPriceInstrument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LastPriceInstrument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "instrument_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LastPriceInstrument, rhs: LastPriceInstrument) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeLastPriceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeLastPriceResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tracking_id"),
    2: .standard(proto: "last_price_subscriptions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trackingID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.lastPriceSubscriptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trackingID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackingID, fieldNumber: 1)
    }
    if !self.lastPriceSubscriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lastPriceSubscriptions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubscribeLastPriceResponse, rhs: SubscribeLastPriceResponse) -> Bool {
    if lhs.trackingID != rhs.trackingID {return false}
    if lhs.lastPriceSubscriptions != rhs.lastPriceSubscriptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LastPriceSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LastPriceSubscription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "subscription_status"),
    3: .standard(proto: "instrument_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.subscriptionStatus) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.subscriptionStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionStatus, fieldNumber: 2)
    }
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LastPriceSubscription, rhs: LastPriceSubscription) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.subscriptionStatus != rhs.subscriptionStatus {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Candle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Candle"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "interval"),
    3: .same(proto: "open"),
    4: .same(proto: "high"),
    5: .same(proto: "low"),
    6: .same(proto: "close"),
    7: .same(proto: "volume"),
    8: .same(proto: "time"),
    9: .standard(proto: "last_trade_ts"),
    10: .standard(proto: "instrument_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.interval) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._open) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._high) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._low) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._close) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.volume) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._lastTradeTs) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.interval != .unspecified {
      try visitor.visitSingularEnumField(value: self.interval, fieldNumber: 2)
    }
    try { if let v = self._open {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._high {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._low {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._close {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.volume != 0 {
      try visitor.visitSingularInt64Field(value: self.volume, fieldNumber: 7)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._lastTradeTs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Candle, rhs: Candle) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.interval != rhs.interval {return false}
    if lhs._open != rhs._open {return false}
    if lhs._high != rhs._high {return false}
    if lhs._low != rhs._low {return false}
    if lhs._close != rhs._close {return false}
    if lhs.volume != rhs.volume {return false}
    if lhs._time != rhs._time {return false}
    if lhs._lastTradeTs != rhs._lastTradeTs {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OrderBook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OrderBook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "depth"),
    3: .standard(proto: "is_consistent"),
    4: .same(proto: "bids"),
    5: .same(proto: "asks"),
    6: .same(proto: "time"),
    7: .standard(proto: "limit_up"),
    8: .standard(proto: "limit_down"),
    9: .standard(proto: "instrument_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.depth) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isConsistent) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.bids) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.asks) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._limitUp) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._limitDown) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.depth != 0 {
      try visitor.visitSingularInt32Field(value: self.depth, fieldNumber: 2)
    }
    if self.isConsistent != false {
      try visitor.visitSingularBoolField(value: self.isConsistent, fieldNumber: 3)
    }
    if !self.bids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bids, fieldNumber: 4)
    }
    if !self.asks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.asks, fieldNumber: 5)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._limitUp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._limitDown {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OrderBook, rhs: OrderBook) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.depth != rhs.depth {return false}
    if lhs.isConsistent != rhs.isConsistent {return false}
    if lhs.bids != rhs.bids {return false}
    if lhs.asks != rhs.asks {return false}
    if lhs._time != rhs._time {return false}
    if lhs._limitUp != rhs._limitUp {return false}
    if lhs._limitDown != rhs._limitDown {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Order: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Order"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "price"),
    2: .same(proto: "quantity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._price) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.quantity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._price {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.quantity != 0 {
      try visitor.visitSingularInt64Field(value: self.quantity, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Order, rhs: Order) -> Bool {
    if lhs._price != rhs._price {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Trade: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Trade"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "direction"),
    3: .same(proto: "price"),
    4: .same(proto: "quantity"),
    5: .same(proto: "time"),
    6: .standard(proto: "instrument_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._price) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.quantity) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.direction != .unspecified {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 2)
    }
    try { if let v = self._price {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.quantity != 0 {
      try visitor.visitSingularInt64Field(value: self.quantity, fieldNumber: 4)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Trade, rhs: Trade) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs._price != rhs._price {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs._time != rhs._time {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TradingStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TradingStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "trading_status"),
    3: .same(proto: "time"),
    4: .standard(proto: "limit_order_available_flag"),
    5: .standard(proto: "market_order_available_flag"),
    6: .standard(proto: "instrument_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.tradingStatus) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.limitOrderAvailableFlag) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.marketOrderAvailableFlag) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.tradingStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.tradingStatus, fieldNumber: 2)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.limitOrderAvailableFlag != false {
      try visitor.visitSingularBoolField(value: self.limitOrderAvailableFlag, fieldNumber: 4)
    }
    if self.marketOrderAvailableFlag != false {
      try visitor.visitSingularBoolField(value: self.marketOrderAvailableFlag, fieldNumber: 5)
    }
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TradingStatus, rhs: TradingStatus) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.tradingStatus != rhs.tradingStatus {return false}
    if lhs._time != rhs._time {return false}
    if lhs.limitOrderAvailableFlag != rhs.limitOrderAvailableFlag {return false}
    if lhs.marketOrderAvailableFlag != rhs.marketOrderAvailableFlag {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetCandlesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCandlesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
    4: .same(proto: "interval"),
    5: .standard(proto: "instrument_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.interval) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.interval != .unspecified {
      try visitor.visitSingularEnumField(value: self.interval, fieldNumber: 4)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetCandlesRequest, rhs: GetCandlesRequest) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs.interval != rhs.interval {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetCandlesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCandlesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "candles"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.candles) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.candles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.candles, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetCandlesResponse, rhs: GetCandlesResponse) -> Bool {
    if lhs.candles != rhs.candles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HistoricCandle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HistoricCandle"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "open"),
    2: .same(proto: "high"),
    3: .same(proto: "low"),
    4: .same(proto: "close"),
    5: .same(proto: "volume"),
    6: .same(proto: "time"),
    7: .standard(proto: "is_complete"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._open) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._high) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._low) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._close) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.volume) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.isComplete) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._open {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._high {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._low {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._close {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.volume != 0 {
      try visitor.visitSingularInt64Field(value: self.volume, fieldNumber: 5)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.isComplete != false {
      try visitor.visitSingularBoolField(value: self.isComplete, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: HistoricCandle, rhs: HistoricCandle) -> Bool {
    if lhs._open != rhs._open {return false}
    if lhs._high != rhs._high {return false}
    if lhs._low != rhs._low {return false}
    if lhs._close != rhs._close {return false}
    if lhs.volume != rhs.volume {return false}
    if lhs._time != rhs._time {return false}
    if lhs.isComplete != rhs.isComplete {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetLastPricesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLastPricesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "instrument_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.instrumentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitRepeatedStringField(value: self.figi, fieldNumber: 1)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitRepeatedStringField(value: self.instrumentID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetLastPricesRequest, rhs: GetLastPricesRequest) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetLastPricesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLastPricesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "last_prices"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.lastPrices) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lastPrices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lastPrices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetLastPricesResponse, rhs: GetLastPricesResponse) -> Bool {
    if lhs.lastPrices != rhs.lastPrices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LastPrice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LastPrice"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "price"),
    3: .same(proto: "time"),
    11: .standard(proto: "instrument_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._price) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    try { if let v = self._price {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LastPrice, rhs: LastPrice) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs._price != rhs._price {return false}
    if lhs._time != rhs._time {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetOrderBookRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetOrderBookRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "depth"),
    3: .standard(proto: "instrument_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.depth) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.depth != 0 {
      try visitor.visitSingularInt32Field(value: self.depth, fieldNumber: 2)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetOrderBookRequest, rhs: GetOrderBookRequest) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.depth != rhs.depth {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetOrderBookResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetOrderBookResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "depth"),
    3: .same(proto: "bids"),
    4: .same(proto: "asks"),
    5: .standard(proto: "last_price"),
    6: .standard(proto: "close_price"),
    7: .standard(proto: "limit_up"),
    8: .standard(proto: "limit_down"),
    21: .standard(proto: "last_price_ts"),
    22: .standard(proto: "close_price_ts"),
    23: .standard(proto: "orderbook_ts"),
    9: .standard(proto: "instrument_uid"),
  ]

  fileprivate class _StorageClass {
    var _figi: String = String()
    var _depth: Int32 = 0
    var _bids: [Order] = []
    var _asks: [Order] = []
    var _lastPrice: Quotation? = nil
    var _closePrice: Quotation? = nil
    var _limitUp: Quotation? = nil
    var _limitDown: Quotation? = nil
    var _lastPriceTs: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _closePriceTs: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _orderbookTs: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _instrumentUid: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _figi = source._figi
      _depth = source._depth
      _bids = source._bids
      _asks = source._asks
      _lastPrice = source._lastPrice
      _closePrice = source._closePrice
      _limitUp = source._limitUp
      _limitDown = source._limitDown
      _lastPriceTs = source._lastPriceTs
      _closePriceTs = source._closePriceTs
      _orderbookTs = source._orderbookTs
      _instrumentUid = source._instrumentUid
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._figi) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._depth) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._bids) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._asks) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._lastPrice) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._closePrice) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._limitUp) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._limitDown) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._instrumentUid) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._lastPriceTs) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._closePriceTs) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._orderbookTs) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._figi.isEmpty {
        try visitor.visitSingularStringField(value: _storage._figi, fieldNumber: 1)
      }
      if _storage._depth != 0 {
        try visitor.visitSingularInt32Field(value: _storage._depth, fieldNumber: 2)
      }
      if !_storage._bids.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._bids, fieldNumber: 3)
      }
      if !_storage._asks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._asks, fieldNumber: 4)
      }
      try { if let v = _storage._lastPrice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._closePrice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._limitUp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._limitDown {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._instrumentUid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._instrumentUid, fieldNumber: 9)
      }
      try { if let v = _storage._lastPriceTs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._closePriceTs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._orderbookTs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetOrderBookResponse, rhs: GetOrderBookResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._figi != rhs_storage._figi {return false}
        if _storage._depth != rhs_storage._depth {return false}
        if _storage._bids != rhs_storage._bids {return false}
        if _storage._asks != rhs_storage._asks {return false}
        if _storage._lastPrice != rhs_storage._lastPrice {return false}
        if _storage._closePrice != rhs_storage._closePrice {return false}
        if _storage._limitUp != rhs_storage._limitUp {return false}
        if _storage._limitDown != rhs_storage._limitDown {return false}
        if _storage._lastPriceTs != rhs_storage._lastPriceTs {return false}
        if _storage._closePriceTs != rhs_storage._closePriceTs {return false}
        if _storage._orderbookTs != rhs_storage._orderbookTs {return false}
        if _storage._instrumentUid != rhs_storage._instrumentUid {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetTradingStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTradingStatusRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "instrument_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetTradingStatusRequest, rhs: GetTradingStatusRequest) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetTradingStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTradingStatusResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "trading_status"),
    3: .standard(proto: "limit_order_available_flag"),
    4: .standard(proto: "market_order_available_flag"),
    5: .standard(proto: "api_trade_available_flag"),
    6: .standard(proto: "instrument_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.tradingStatus) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.limitOrderAvailableFlag) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.marketOrderAvailableFlag) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.apiTradeAvailableFlag) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.tradingStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.tradingStatus, fieldNumber: 2)
    }
    if self.limitOrderAvailableFlag != false {
      try visitor.visitSingularBoolField(value: self.limitOrderAvailableFlag, fieldNumber: 3)
    }
    if self.marketOrderAvailableFlag != false {
      try visitor.visitSingularBoolField(value: self.marketOrderAvailableFlag, fieldNumber: 4)
    }
    if self.apiTradeAvailableFlag != false {
      try visitor.visitSingularBoolField(value: self.apiTradeAvailableFlag, fieldNumber: 5)
    }
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetTradingStatusResponse, rhs: GetTradingStatusResponse) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.tradingStatus != rhs.tradingStatus {return false}
    if lhs.limitOrderAvailableFlag != rhs.limitOrderAvailableFlag {return false}
    if lhs.marketOrderAvailableFlag != rhs.marketOrderAvailableFlag {return false}
    if lhs.apiTradeAvailableFlag != rhs.apiTradeAvailableFlag {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetLastTradesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLastTradesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
    4: .standard(proto: "instrument_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetLastTradesRequest, rhs: GetLastTradesRequest) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetLastTradesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLastTradesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "trades"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.trades) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trades.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.trades, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetLastTradesResponse, rhs: GetLastTradesResponse) -> Bool {
    if lhs.trades != rhs.trades {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetMySubscriptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetMySubscriptions"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetMySubscriptions, rhs: GetMySubscriptions) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetClosePricesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetClosePricesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetClosePricesRequest, rhs: GetClosePricesRequest) -> Bool {
    if lhs.instruments != rhs.instruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InstrumentClosePriceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InstrumentClosePriceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instrument_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InstrumentClosePriceRequest, rhs: InstrumentClosePriceRequest) -> Bool {
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetClosePricesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetClosePricesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "close_prices"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.closePrices) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.closePrices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.closePrices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetClosePricesResponse, rhs: GetClosePricesResponse) -> Bool {
    if lhs.closePrices != rhs.closePrices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InstrumentClosePriceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InstrumentClosePriceResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "instrument_uid"),
    11: .same(proto: "price"),
    21: .same(proto: "time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._price) }()
      case 21: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 2)
    }
    try { if let v = self._price {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InstrumentClosePriceResponse, rhs: InstrumentClosePriceResponse) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs._price != rhs._price {return false}
    if lhs._time != rhs._time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
