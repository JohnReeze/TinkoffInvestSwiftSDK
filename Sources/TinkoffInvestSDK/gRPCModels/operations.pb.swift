// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: operations.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///Статус запрашиваемых операций.
public enum OperationState: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Статус операции не определён
  case unspecified // = 0

  ///Исполнена.
  case executed // = 1

  ///Отменена.
  case canceled // = 2

  ///Исполняется.
  case progress // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .executed
    case 2: self = .canceled
    case 3: self = .progress
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .executed: return 1
    case .canceled: return 2
    case .progress: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension OperationState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [OperationState] = [
    .unspecified,
    .executed,
    .canceled,
    .progress,
  ]
}

#endif  // swift(>=4.2)

///Тип операции.
public enum OperationType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Тип операции не определён.
  case unspecified // = 0

  ///Пополнение брокерского счёта.
  case input // = 1

  ///Удержание НДФЛ по купонам.
  case bondTax // = 2

  ///Вывод ЦБ.
  case outputSecurities // = 3

  ///Доход по сделке РЕПО овернайт.
  case overnight // = 4

  ///Удержание налога.
  case tax // = 5

  ///Полное погашение облигаций.
  case bondRepaymentFull // = 6

  ///Продажа ЦБ с карты.
  case sellCard // = 7

  ///Удержание налога по дивидендам.
  case dividendTax // = 8

  ///Вывод денежных средств.
  case output // = 9

  ///Частичное погашение облигаций.
  case bondRepayment // = 10

  ///Корректировка налога.
  case taxCorrection // = 11

  ///Удержание комиссии за обслуживание брокерского счёта.
  case serviceFee // = 12

  ///Удержание налога за материальную выгоду.
  case benefitTax // = 13

  ///Удержание комиссии за непокрытую позицию.
  case marginFee // = 14

  ///Покупка ЦБ.
  case buy // = 15

  ///Покупка ЦБ с карты.
  case buyCard // = 16

  ///Перевод ценных бумаг из другого депозитария.
  case inputSecurities // = 17

  ///Продажа в результате Margin-call.
  case sellMargin // = 18

  ///Удержание комиссии за операцию.
  case brokerFee // = 19

  ///Покупка в результате Margin-call.
  case buyMargin // = 20

  ///Выплата дивидендов.
  case dividend // = 21

  ///Продажа ЦБ.
  case sell // = 22

  ///Выплата купонов.
  case coupon // = 23

  ///Удержание комиссии SuccessFee.
  case successFee // = 24

  ///Передача дивидендного дохода.
  case dividendTransfer // = 25

  ///Зачисление вариационной маржи.
  case accruingVarmargin // = 26

  ///Списание вариационной маржи.
  case writingOffVarmargin // = 27

  ///Покупка в рамках экспирации фьючерсного контракта.
  case deliveryBuy // = 28

  ///Продажа в рамках экспирации фьючерсного контракта.
  case deliverySell // = 29

  ///Комиссия за управление по счёту автоследования.
  case trackMfee // = 30

  ///Комиссия за результат по счёту автоследования.
  case trackPfee // = 31

  ///Удержание налога по ставке 15%.
  case taxProgressive // = 32

  ///Удержание налога по купонам по ставке 15%.
  case bondTaxProgressive // = 33

  ///Удержание налога по дивидендам по ставке 15%.
  case dividendTaxProgressive // = 34

  ///Удержание налога за материальную выгоду по ставке 15%.
  case benefitTaxProgressive // = 35

  ///Корректировка налога по ставке 15%.
  case taxCorrectionProgressive // = 36

  ///Удержание налога за возмещение по сделкам РЕПО по ставке 15%.
  case taxRepoProgressive // = 37

  ///Удержание налога за возмещение по сделкам РЕПО.
  case taxRepo // = 38

  ///Удержание налога по сделкам РЕПО.
  case taxRepoHold // = 39

  ///Возврат налога по сделкам РЕПО.
  case taxRepoRefund // = 40

  ///Удержание налога по сделкам РЕПО по ставке 15%.
  case taxRepoHoldProgressive // = 41

  ///Возврат налога по сделкам РЕПО по ставке 15%.
  case taxRepoRefundProgressive // = 42

  ///Выплата дивидендов на карту.
  case divExt // = 43

  ///Корректировка налога по купонам.
  case taxCorrectionCoupon // = 44

  ///Комиссия за валютный остаток.
  case cashFee // = 45

  ///Комиссия за вывод валюты с брокерского счета.
  case outFee // = 46

  ///Гербовый сбор.
  case outStampDuty // = 47
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .input
    case 2: self = .bondTax
    case 3: self = .outputSecurities
    case 4: self = .overnight
    case 5: self = .tax
    case 6: self = .bondRepaymentFull
    case 7: self = .sellCard
    case 8: self = .dividendTax
    case 9: self = .output
    case 10: self = .bondRepayment
    case 11: self = .taxCorrection
    case 12: self = .serviceFee
    case 13: self = .benefitTax
    case 14: self = .marginFee
    case 15: self = .buy
    case 16: self = .buyCard
    case 17: self = .inputSecurities
    case 18: self = .sellMargin
    case 19: self = .brokerFee
    case 20: self = .buyMargin
    case 21: self = .dividend
    case 22: self = .sell
    case 23: self = .coupon
    case 24: self = .successFee
    case 25: self = .dividendTransfer
    case 26: self = .accruingVarmargin
    case 27: self = .writingOffVarmargin
    case 28: self = .deliveryBuy
    case 29: self = .deliverySell
    case 30: self = .trackMfee
    case 31: self = .trackPfee
    case 32: self = .taxProgressive
    case 33: self = .bondTaxProgressive
    case 34: self = .dividendTaxProgressive
    case 35: self = .benefitTaxProgressive
    case 36: self = .taxCorrectionProgressive
    case 37: self = .taxRepoProgressive
    case 38: self = .taxRepo
    case 39: self = .taxRepoHold
    case 40: self = .taxRepoRefund
    case 41: self = .taxRepoHoldProgressive
    case 42: self = .taxRepoRefundProgressive
    case 43: self = .divExt
    case 44: self = .taxCorrectionCoupon
    case 45: self = .cashFee
    case 46: self = .outFee
    case 47: self = .outStampDuty
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .input: return 1
    case .bondTax: return 2
    case .outputSecurities: return 3
    case .overnight: return 4
    case .tax: return 5
    case .bondRepaymentFull: return 6
    case .sellCard: return 7
    case .dividendTax: return 8
    case .output: return 9
    case .bondRepayment: return 10
    case .taxCorrection: return 11
    case .serviceFee: return 12
    case .benefitTax: return 13
    case .marginFee: return 14
    case .buy: return 15
    case .buyCard: return 16
    case .inputSecurities: return 17
    case .sellMargin: return 18
    case .brokerFee: return 19
    case .buyMargin: return 20
    case .dividend: return 21
    case .sell: return 22
    case .coupon: return 23
    case .successFee: return 24
    case .dividendTransfer: return 25
    case .accruingVarmargin: return 26
    case .writingOffVarmargin: return 27
    case .deliveryBuy: return 28
    case .deliverySell: return 29
    case .trackMfee: return 30
    case .trackPfee: return 31
    case .taxProgressive: return 32
    case .bondTaxProgressive: return 33
    case .dividendTaxProgressive: return 34
    case .benefitTaxProgressive: return 35
    case .taxCorrectionProgressive: return 36
    case .taxRepoProgressive: return 37
    case .taxRepo: return 38
    case .taxRepoHold: return 39
    case .taxRepoRefund: return 40
    case .taxRepoHoldProgressive: return 41
    case .taxRepoRefundProgressive: return 42
    case .divExt: return 43
    case .taxCorrectionCoupon: return 44
    case .cashFee: return 45
    case .outFee: return 46
    case .outStampDuty: return 47
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension OperationType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [OperationType] = [
    .unspecified,
    .input,
    .bondTax,
    .outputSecurities,
    .overnight,
    .tax,
    .bondRepaymentFull,
    .sellCard,
    .dividendTax,
    .output,
    .bondRepayment,
    .taxCorrection,
    .serviceFee,
    .benefitTax,
    .marginFee,
    .buy,
    .buyCard,
    .inputSecurities,
    .sellMargin,
    .brokerFee,
    .buyMargin,
    .dividend,
    .sell,
    .coupon,
    .successFee,
    .dividendTransfer,
    .accruingVarmargin,
    .writingOffVarmargin,
    .deliveryBuy,
    .deliverySell,
    .trackMfee,
    .trackPfee,
    .taxProgressive,
    .bondTaxProgressive,
    .dividendTaxProgressive,
    .benefitTaxProgressive,
    .taxCorrectionProgressive,
    .taxRepoProgressive,
    .taxRepo,
    .taxRepoHold,
    .taxRepoRefund,
    .taxRepoHoldProgressive,
    .taxRepoRefundProgressive,
    .divExt,
    .taxCorrectionCoupon,
    .cashFee,
    .outFee,
    .outStampDuty,
  ]
}

#endif  // swift(>=4.2)

///Результат подписки.
public enum PortfolioSubscriptionStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Тип не определён.
  case unspecified // = 0

  ///Успешно.
  case success // = 1

  ///Счёт не найден или недостаточно прав.
  case accountNotFound // = 2

  ///Произошла ошибка.
  case internalError // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .success
    case 2: self = .accountNotFound
    case 3: self = .internalError
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .success: return 1
    case .accountNotFound: return 2
    case .internalError: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PortfolioSubscriptionStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [PortfolioSubscriptionStatus] = [
    .unspecified,
    .success,
    .accountNotFound,
    .internalError,
  ]
}

#endif  // swift(>=4.2)

///Тип инструмента.
public enum InstrumentType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unspecified // = 0

  ///Облигация.
  case bond // = 1

  ///Акция.
  case share // = 2

  ///Валюта.
  case currency // = 3

  ///Exchange-traded fund. Фонд.
  case etf // = 4

  ///Фьючерс.
  case futures // = 5

  ///Структурная нота.
  case sp // = 6

  ///Опцион.
  case option // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .bond
    case 2: self = .share
    case 3: self = .currency
    case 4: self = .etf
    case 5: self = .futures
    case 6: self = .sp
    case 7: self = .option
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .bond: return 1
    case .share: return 2
    case .currency: return 3
    case .etf: return 4
    case .futures: return 5
    case .sp: return 6
    case .option: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension InstrumentType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [InstrumentType] = [
    .unspecified,
    .bond,
    .share,
    .currency,
    .etf,
    .futures,
    .sp,
    .option,
  ]
}

#endif  // swift(>=4.2)

///Результат подписки.
public enum PositionsAccountSubscriptionStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Тип не определён.
  case positionsSubscriptionStatusUnspecified // = 0

  ///Успешно.
  case positionsSubscriptionStatusSuccess // = 1

  ///Счёт не найден или недостаточно прав.
  case positionsSubscriptionStatusAccountNotFound // = 2

  ///Произошла ошибка.
  case positionsSubscriptionStatusInternalError // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .positionsSubscriptionStatusUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .positionsSubscriptionStatusUnspecified
    case 1: self = .positionsSubscriptionStatusSuccess
    case 2: self = .positionsSubscriptionStatusAccountNotFound
    case 3: self = .positionsSubscriptionStatusInternalError
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .positionsSubscriptionStatusUnspecified: return 0
    case .positionsSubscriptionStatusSuccess: return 1
    case .positionsSubscriptionStatusAccountNotFound: return 2
    case .positionsSubscriptionStatusInternalError: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PositionsAccountSubscriptionStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [PositionsAccountSubscriptionStatus] = [
    .positionsSubscriptionStatusUnspecified,
    .positionsSubscriptionStatusSuccess,
    .positionsSubscriptionStatusAccountNotFound,
    .positionsSubscriptionStatusInternalError,
  ]
}

#endif  // swift(>=4.2)

///Запрос получения списка операций по счёту.
public struct OperationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор счёта клиента.
  public var accountID: String = String()

  ///Начало периода (по UTC).
  public var from: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  public var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  public mutating func clearFrom() {self._from = nil}

  ///Окончание периода (по UTC).
  public var to: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  public var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  public mutating func clearTo() {self._to = nil}

  ///Статус запрашиваемых операций.
  public var state: OperationState = .unspecified

  ///Figi-идентификатор инструмента для фильтрации.
  public var figi: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Список операций.
public struct OperationsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив операций.
  public var operations: [Operation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Данные по операции.
public struct Operation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор операции.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  ///Идентификатор родительской операции.
  public var parentOperationID: String {
    get {return _storage._parentOperationID}
    set {_uniqueStorage()._parentOperationID = newValue}
  }

  ///Валюта операции.
  public var currency: String {
    get {return _storage._currency}
    set {_uniqueStorage()._currency = newValue}
  }

  ///Сумма операции.
  public var payment: MoneyValue {
    get {return _storage._payment ?? MoneyValue()}
    set {_uniqueStorage()._payment = newValue}
  }
  /// Returns true if `payment` has been explicitly set.
  public var hasPayment: Bool {return _storage._payment != nil}
  /// Clears the value of `payment`. Subsequent reads from it will return its default value.
  public mutating func clearPayment() {_uniqueStorage()._payment = nil}

  ///Цена операции за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента.
  public var price: MoneyValue {
    get {return _storage._price ?? MoneyValue()}
    set {_uniqueStorage()._price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  public var hasPrice: Bool {return _storage._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  public mutating func clearPrice() {_uniqueStorage()._price = nil}

  ///Статус операции.
  public var state: OperationState {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  ///Количество единиц инструмента.
  public var quantity: Int64 {
    get {return _storage._quantity}
    set {_uniqueStorage()._quantity = newValue}
  }

  ///Неисполненный остаток по сделке.
  public var quantityRest: Int64 {
    get {return _storage._quantityRest}
    set {_uniqueStorage()._quantityRest = newValue}
  }

  ///Figi-идентификатор инструмента, связанного с операцией.
  public var figi: String {
    get {return _storage._figi}
    set {_uniqueStorage()._figi = newValue}
  }

  ///Тип инструмента. Возможные значения: </br>**bond** — облигация; </br>**share** — акция; </br>**currency** — валюта; </br>**etf** — фонд; </br>**futures** — фьючерс.
  public var instrumentType: String {
    get {return _storage._instrumentType}
    set {_uniqueStorage()._instrumentType = newValue}
  }

  ///Дата и время операции в формате часовом поясе UTC.
  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return _storage._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {_uniqueStorage()._date = nil}

  ///Текстовое описание типа операции.
  public var type: String {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  ///Тип операции.
  public var operationType: OperationType {
    get {return _storage._operationType}
    set {_uniqueStorage()._operationType = newValue}
  }

  ///Массив сделок.
  public var trades: [OperationTrade] {
    get {return _storage._trades}
    set {_uniqueStorage()._trades = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Сделка по операции.
public struct OperationTrade {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор сделки.
  public var tradeID: String = String()

  ///Дата и время сделки в часовом поясе UTC.
  public var dateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _dateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_dateTime = newValue}
  }
  /// Returns true if `dateTime` has been explicitly set.
  public var hasDateTime: Bool {return self._dateTime != nil}
  /// Clears the value of `dateTime`. Subsequent reads from it will return its default value.
  public mutating func clearDateTime() {self._dateTime = nil}

  ///Количество инструментов.
  public var quantity: Int64 = 0

  ///Цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента.
  public var price: MoneyValue {
    get {return _price ?? MoneyValue()}
    set {_price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  public var hasPrice: Bool {return self._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  public mutating func clearPrice() {self._price = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _dateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _price: MoneyValue? = nil
}

///Запрос получения текущего портфеля по счёту.
public struct PortfolioRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор счёта пользователя.
  public var accountID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Текущий портфель по счёту.
public struct PortfolioResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Общая стоимость акций в портфеле в рублях.
  public var totalAmountShares: MoneyValue {
    get {return _storage._totalAmountShares ?? MoneyValue()}
    set {_uniqueStorage()._totalAmountShares = newValue}
  }
  /// Returns true if `totalAmountShares` has been explicitly set.
  public var hasTotalAmountShares: Bool {return _storage._totalAmountShares != nil}
  /// Clears the value of `totalAmountShares`. Subsequent reads from it will return its default value.
  public mutating func clearTotalAmountShares() {_uniqueStorage()._totalAmountShares = nil}

  ///Общая стоимость облигаций в портфеле в рублях.
  public var totalAmountBonds: MoneyValue {
    get {return _storage._totalAmountBonds ?? MoneyValue()}
    set {_uniqueStorage()._totalAmountBonds = newValue}
  }
  /// Returns true if `totalAmountBonds` has been explicitly set.
  public var hasTotalAmountBonds: Bool {return _storage._totalAmountBonds != nil}
  /// Clears the value of `totalAmountBonds`. Subsequent reads from it will return its default value.
  public mutating func clearTotalAmountBonds() {_uniqueStorage()._totalAmountBonds = nil}

  ///Общая стоимость фондов в портфеле в рублях.
  public var totalAmountEtf: MoneyValue {
    get {return _storage._totalAmountEtf ?? MoneyValue()}
    set {_uniqueStorage()._totalAmountEtf = newValue}
  }
  /// Returns true if `totalAmountEtf` has been explicitly set.
  public var hasTotalAmountEtf: Bool {return _storage._totalAmountEtf != nil}
  /// Clears the value of `totalAmountEtf`. Subsequent reads from it will return its default value.
  public mutating func clearTotalAmountEtf() {_uniqueStorage()._totalAmountEtf = nil}

  ///Общая стоимость валют в портфеле в рублях.
  public var totalAmountCurrencies: MoneyValue {
    get {return _storage._totalAmountCurrencies ?? MoneyValue()}
    set {_uniqueStorage()._totalAmountCurrencies = newValue}
  }
  /// Returns true if `totalAmountCurrencies` has been explicitly set.
  public var hasTotalAmountCurrencies: Bool {return _storage._totalAmountCurrencies != nil}
  /// Clears the value of `totalAmountCurrencies`. Subsequent reads from it will return its default value.
  public mutating func clearTotalAmountCurrencies() {_uniqueStorage()._totalAmountCurrencies = nil}

  ///Общая стоимость фьючерсов в портфеле в рублях.
  public var totalAmountFutures: MoneyValue {
    get {return _storage._totalAmountFutures ?? MoneyValue()}
    set {_uniqueStorage()._totalAmountFutures = newValue}
  }
  /// Returns true if `totalAmountFutures` has been explicitly set.
  public var hasTotalAmountFutures: Bool {return _storage._totalAmountFutures != nil}
  /// Clears the value of `totalAmountFutures`. Subsequent reads from it will return its default value.
  public mutating func clearTotalAmountFutures() {_uniqueStorage()._totalAmountFutures = nil}

  ///Текущая относительная доходность портфеля, в %.
  public var expectedYield: Quotation {
    get {return _storage._expectedYield ?? Quotation()}
    set {_uniqueStorage()._expectedYield = newValue}
  }
  /// Returns true if `expectedYield` has been explicitly set.
  public var hasExpectedYield: Bool {return _storage._expectedYield != nil}
  /// Clears the value of `expectedYield`. Subsequent reads from it will return its default value.
  public mutating func clearExpectedYield() {_uniqueStorage()._expectedYield = nil}

  ///Список позиций портфеля.
  public var positions: [PortfolioPosition] {
    get {return _storage._positions}
    set {_uniqueStorage()._positions = newValue}
  }

  ///Идентификатор счёта пользователя.
  public var accountID: String {
    get {return _storage._accountID}
    set {_uniqueStorage()._accountID = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Запрос позиций портфеля по счёту.
public struct PositionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор счёта пользователя.
  public var accountID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Список позиций по счёту.
public struct PositionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив валютных позиций портфеля.
  public var money: [MoneyValue] = []

  ///Массив заблокированных валютных позиций портфеля.
  public var blocked: [MoneyValue] = []

  ///Список ценно-бумажных позиций портфеля.
  public var securities: [PositionsSecurities] = []

  ///Признак идущей в данный момент выгрузки лимитов.
  public var limitsLoadingInProgress: Bool = false

  ///Список фьючерсов портфеля.
  public var futures: [PositionsFutures] = []

  ///Список опционов портфеля.
  public var options: [PositionsOptions] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос доступного для вывода остатка.
public struct WithdrawLimitsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор счёта пользователя.
  public var accountID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Доступный для вывода остаток.
public struct WithdrawLimitsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив валютных позиций портфеля.
  public var money: [MoneyValue] = []

  ///Массив заблокированных валютных позиций портфеля.
  public var blocked: [MoneyValue] = []

  ///Заблокировано под гарантийное обеспечение фьючерсов.
  public var blockedGuarantee: [MoneyValue] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Позиции портфеля.
public struct PortfolioPosition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатора инструмента.
  public var figi: String {
    get {return _storage._figi}
    set {_uniqueStorage()._figi = newValue}
  }

  ///Тип инструмента.
  public var instrumentType: String {
    get {return _storage._instrumentType}
    set {_uniqueStorage()._instrumentType = newValue}
  }

  ///Количество инструмента в портфеле в штуках.
  public var quantity: Quotation {
    get {return _storage._quantity ?? Quotation()}
    set {_uniqueStorage()._quantity = newValue}
  }
  /// Returns true if `quantity` has been explicitly set.
  public var hasQuantity: Bool {return _storage._quantity != nil}
  /// Clears the value of `quantity`. Subsequent reads from it will return its default value.
  public mutating func clearQuantity() {_uniqueStorage()._quantity = nil}

  ///Средневзвешенная цена позиции. **Возможна задержка до секунды для пересчёта**.
  public var averagePositionPrice: MoneyValue {
    get {return _storage._averagePositionPrice ?? MoneyValue()}
    set {_uniqueStorage()._averagePositionPrice = newValue}
  }
  /// Returns true if `averagePositionPrice` has been explicitly set.
  public var hasAveragePositionPrice: Bool {return _storage._averagePositionPrice != nil}
  /// Clears the value of `averagePositionPrice`. Subsequent reads from it will return its default value.
  public mutating func clearAveragePositionPrice() {_uniqueStorage()._averagePositionPrice = nil}

  ///Текущая рассчитанная доходность позиции.
  public var expectedYield: Quotation {
    get {return _storage._expectedYield ?? Quotation()}
    set {_uniqueStorage()._expectedYield = newValue}
  }
  /// Returns true if `expectedYield` has been explicitly set.
  public var hasExpectedYield: Bool {return _storage._expectedYield != nil}
  /// Clears the value of `expectedYield`. Subsequent reads from it will return its default value.
  public mutating func clearExpectedYield() {_uniqueStorage()._expectedYield = nil}

  /// Текущий НКД.
  public var currentNkd: MoneyValue {
    get {return _storage._currentNkd ?? MoneyValue()}
    set {_uniqueStorage()._currentNkd = newValue}
  }
  /// Returns true if `currentNkd` has been explicitly set.
  public var hasCurrentNkd: Bool {return _storage._currentNkd != nil}
  /// Clears the value of `currentNkd`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentNkd() {_uniqueStorage()._currentNkd = nil}

  ///Средняя цена позиции в пунктах (для фьючерсов). **Возможна задержка до секунды для пересчёта**.
  public var averagePositionPricePt: Quotation {
    get {return _storage._averagePositionPricePt ?? Quotation()}
    set {_uniqueStorage()._averagePositionPricePt = newValue}
  }
  /// Returns true if `averagePositionPricePt` has been explicitly set.
  public var hasAveragePositionPricePt: Bool {return _storage._averagePositionPricePt != nil}
  /// Clears the value of `averagePositionPricePt`. Subsequent reads from it will return its default value.
  public mutating func clearAveragePositionPricePt() {_uniqueStorage()._averagePositionPricePt = nil}

  ///Текущая цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента..
  public var currentPrice: MoneyValue {
    get {return _storage._currentPrice ?? MoneyValue()}
    set {_uniqueStorage()._currentPrice = newValue}
  }
  /// Returns true if `currentPrice` has been explicitly set.
  public var hasCurrentPrice: Bool {return _storage._currentPrice != nil}
  /// Clears the value of `currentPrice`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentPrice() {_uniqueStorage()._currentPrice = nil}

  ///Средняя цена позиции по методу FIFO. **Возможна задержка до секунды для пересчёта**.
  public var averagePositionPriceFifo: MoneyValue {
    get {return _storage._averagePositionPriceFifo ?? MoneyValue()}
    set {_uniqueStorage()._averagePositionPriceFifo = newValue}
  }
  /// Returns true if `averagePositionPriceFifo` has been explicitly set.
  public var hasAveragePositionPriceFifo: Bool {return _storage._averagePositionPriceFifo != nil}
  /// Clears the value of `averagePositionPriceFifo`. Subsequent reads from it will return its default value.
  public mutating func clearAveragePositionPriceFifo() {_uniqueStorage()._averagePositionPriceFifo = nil}

  ///Количество лотов в портфеле.
  public var quantityLots: Quotation {
    get {return _storage._quantityLots ?? Quotation()}
    set {_uniqueStorage()._quantityLots = newValue}
  }
  /// Returns true if `quantityLots` has been explicitly set.
  public var hasQuantityLots: Bool {return _storage._quantityLots != nil}
  /// Clears the value of `quantityLots`. Subsequent reads from it will return its default value.
  public mutating func clearQuantityLots() {_uniqueStorage()._quantityLots = nil}

  ///Заблокировано.
  public var blocked: Bool {
    get {return _storage._blocked}
    set {_uniqueStorage()._blocked = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Баланс позиции ценной бумаги.
public struct PositionsSecurities {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор бумаги.
  public var figi: String = String()

  ///Заблокировано.
  public var blocked: Int64 = 0

  ///Текущий незаблокированный баланс.
  public var balance: Int64 = 0

  ///Уникальный идентификатор позиции.
  public var positionUid: String = String()

  ///Уникальный идентификатор  инструмента.
  public var instrumentUid: String = String()

  ///Заблокировано на бирже.
  public var exchangeBlocked: Bool = false

  ///Тип инструмента.
  public var instrumentType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Баланс фьючерса.
public struct PositionsFutures {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор фьючерса.
  public var figi: String = String()

  ///Заблокировано.
  public var blocked: Int64 = 0

  ///Текущий незаблокированный баланс.
  public var balance: Int64 = 0

  ///Уникальный идентификатор позиции.
  public var positionUid: String = String()

  ///Уникальный идентификатор  инструмента.
  public var instrumentUid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Баланс опциона.
public struct PositionsOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Уникальный идентификатор позиции опциона.
  public var positionUid: String = String()

  ///Уникальный идентификатор  инструмента.
  public var instrumentUid: String = String()

  ///Заблокировано.
  public var blocked: Int64 = 0

  ///Текущий незаблокированный баланс.
  public var balance: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BrokerReportRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: BrokerReportRequest.OneOf_Payload? = nil

  public var generateBrokerReportRequest: GenerateBrokerReportRequest {
    get {
      if case .generateBrokerReportRequest(let v)? = payload {return v}
      return GenerateBrokerReportRequest()
    }
    set {payload = .generateBrokerReportRequest(newValue)}
  }

  public var getBrokerReportRequest: GetBrokerReportRequest {
    get {
      if case .getBrokerReportRequest(let v)? = payload {return v}
      return GetBrokerReportRequest()
    }
    set {payload = .getBrokerReportRequest(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case generateBrokerReportRequest(GenerateBrokerReportRequest)
    case getBrokerReportRequest(GetBrokerReportRequest)

  #if !swift(>=4.1)
    public static func ==(lhs: BrokerReportRequest.OneOf_Payload, rhs: BrokerReportRequest.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.generateBrokerReportRequest, .generateBrokerReportRequest): return {
        guard case .generateBrokerReportRequest(let l) = lhs, case .generateBrokerReportRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getBrokerReportRequest, .getBrokerReportRequest): return {
        guard case .getBrokerReportRequest(let l) = lhs, case .getBrokerReportRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct BrokerReportResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: BrokerReportResponse.OneOf_Payload? = nil

  public var generateBrokerReportResponse: GenerateBrokerReportResponse {
    get {
      if case .generateBrokerReportResponse(let v)? = payload {return v}
      return GenerateBrokerReportResponse()
    }
    set {payload = .generateBrokerReportResponse(newValue)}
  }

  public var getBrokerReportResponse: GetBrokerReportResponse {
    get {
      if case .getBrokerReportResponse(let v)? = payload {return v}
      return GetBrokerReportResponse()
    }
    set {payload = .getBrokerReportResponse(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case generateBrokerReportResponse(GenerateBrokerReportResponse)
    case getBrokerReportResponse(GetBrokerReportResponse)

  #if !swift(>=4.1)
    public static func ==(lhs: BrokerReportResponse.OneOf_Payload, rhs: BrokerReportResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.generateBrokerReportResponse, .generateBrokerReportResponse): return {
        guard case .generateBrokerReportResponse(let l) = lhs, case .generateBrokerReportResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getBrokerReportResponse, .getBrokerReportResponse): return {
        guard case .getBrokerReportResponse(let l) = lhs, case .getBrokerReportResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct GenerateBrokerReportRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор счёта клиента.
  public var accountID: String = String()

  ///Начало периода в часовом поясе UTC.
  public var from: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  public var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  public mutating func clearFrom() {self._from = nil}

  ///Окончание периода в часовом поясе UTC.
  public var to: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  public var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  public mutating func clearTo() {self._to = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct GenerateBrokerReportResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор задачи формирования брокерского отчёта.
  public var taskID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GetBrokerReportRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор задачи формирования брокерского отчёта.
  public var taskID: String = String()

  ///Номер страницы отчета (начинается с 1), значение по умолчанию: 0.
  public var page: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GetBrokerReportResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var brokerReport: [BrokerReport] = []

  ///Количество записей в отчете.
  public var itemsCount: Int32 = 0

  ///Количество страниц с данными отчета (начинается с 0).
  public var pagesCount: Int32 = 0

  ///Текущая страница (начинается с 0).
  public var page: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BrokerReport {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Номер сделки.
  public var tradeID: String {
    get {return _storage._tradeID}
    set {_uniqueStorage()._tradeID = newValue}
  }

  ///Номер поручения.
  public var orderID: String {
    get {return _storage._orderID}
    set {_uniqueStorage()._orderID = newValue}
  }

  ///Figi-идентификатор инструмента.
  public var figi: String {
    get {return _storage._figi}
    set {_uniqueStorage()._figi = newValue}
  }

  ///Признак исполнения.
  public var executeSign: String {
    get {return _storage._executeSign}
    set {_uniqueStorage()._executeSign = newValue}
  }

  ///Дата и время заключения в часовом поясе UTC.
  public var tradeDatetime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._tradeDatetime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._tradeDatetime = newValue}
  }
  /// Returns true if `tradeDatetime` has been explicitly set.
  public var hasTradeDatetime: Bool {return _storage._tradeDatetime != nil}
  /// Clears the value of `tradeDatetime`. Subsequent reads from it will return its default value.
  public mutating func clearTradeDatetime() {_uniqueStorage()._tradeDatetime = nil}

  ///Торговая площадка.
  public var exchange: String {
    get {return _storage._exchange}
    set {_uniqueStorage()._exchange = newValue}
  }

  ///Режим торгов.
  public var classCode: String {
    get {return _storage._classCode}
    set {_uniqueStorage()._classCode = newValue}
  }

  ///Вид сделки.
  public var direction: String {
    get {return _storage._direction}
    set {_uniqueStorage()._direction = newValue}
  }

  ///Сокращённое наименование актива.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  ///Код актива.
  public var ticker: String {
    get {return _storage._ticker}
    set {_uniqueStorage()._ticker = newValue}
  }

  ///Цена за единицу.
  public var price: MoneyValue {
    get {return _storage._price ?? MoneyValue()}
    set {_uniqueStorage()._price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  public var hasPrice: Bool {return _storage._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  public mutating func clearPrice() {_uniqueStorage()._price = nil}

  ///Количество.
  public var quantity: Int64 {
    get {return _storage._quantity}
    set {_uniqueStorage()._quantity = newValue}
  }

  ///Сумма (без НКД).
  public var orderAmount: MoneyValue {
    get {return _storage._orderAmount ?? MoneyValue()}
    set {_uniqueStorage()._orderAmount = newValue}
  }
  /// Returns true if `orderAmount` has been explicitly set.
  public var hasOrderAmount: Bool {return _storage._orderAmount != nil}
  /// Clears the value of `orderAmount`. Subsequent reads from it will return its default value.
  public mutating func clearOrderAmount() {_uniqueStorage()._orderAmount = nil}

  ///НКД.
  public var aciValue: Quotation {
    get {return _storage._aciValue ?? Quotation()}
    set {_uniqueStorage()._aciValue = newValue}
  }
  /// Returns true if `aciValue` has been explicitly set.
  public var hasAciValue: Bool {return _storage._aciValue != nil}
  /// Clears the value of `aciValue`. Subsequent reads from it will return its default value.
  public mutating func clearAciValue() {_uniqueStorage()._aciValue = nil}

  ///Сумма сделки.
  public var totalOrderAmount: MoneyValue {
    get {return _storage._totalOrderAmount ?? MoneyValue()}
    set {_uniqueStorage()._totalOrderAmount = newValue}
  }
  /// Returns true if `totalOrderAmount` has been explicitly set.
  public var hasTotalOrderAmount: Bool {return _storage._totalOrderAmount != nil}
  /// Clears the value of `totalOrderAmount`. Subsequent reads from it will return its default value.
  public mutating func clearTotalOrderAmount() {_uniqueStorage()._totalOrderAmount = nil}

  ///Комиссия брокера.
  public var brokerCommission: MoneyValue {
    get {return _storage._brokerCommission ?? MoneyValue()}
    set {_uniqueStorage()._brokerCommission = newValue}
  }
  /// Returns true if `brokerCommission` has been explicitly set.
  public var hasBrokerCommission: Bool {return _storage._brokerCommission != nil}
  /// Clears the value of `brokerCommission`. Subsequent reads from it will return its default value.
  public mutating func clearBrokerCommission() {_uniqueStorage()._brokerCommission = nil}

  ///Комиссия биржи.
  public var exchangeCommission: MoneyValue {
    get {return _storage._exchangeCommission ?? MoneyValue()}
    set {_uniqueStorage()._exchangeCommission = newValue}
  }
  /// Returns true if `exchangeCommission` has been explicitly set.
  public var hasExchangeCommission: Bool {return _storage._exchangeCommission != nil}
  /// Clears the value of `exchangeCommission`. Subsequent reads from it will return its default value.
  public mutating func clearExchangeCommission() {_uniqueStorage()._exchangeCommission = nil}

  ///Комиссия клир. центра.
  public var exchangeClearingCommission: MoneyValue {
    get {return _storage._exchangeClearingCommission ?? MoneyValue()}
    set {_uniqueStorage()._exchangeClearingCommission = newValue}
  }
  /// Returns true if `exchangeClearingCommission` has been explicitly set.
  public var hasExchangeClearingCommission: Bool {return _storage._exchangeClearingCommission != nil}
  /// Clears the value of `exchangeClearingCommission`. Subsequent reads from it will return its default value.
  public mutating func clearExchangeClearingCommission() {_uniqueStorage()._exchangeClearingCommission = nil}

  ///Ставка РЕПО (%).
  public var repoRate: Quotation {
    get {return _storage._repoRate ?? Quotation()}
    set {_uniqueStorage()._repoRate = newValue}
  }
  /// Returns true if `repoRate` has been explicitly set.
  public var hasRepoRate: Bool {return _storage._repoRate != nil}
  /// Clears the value of `repoRate`. Subsequent reads from it will return its default value.
  public mutating func clearRepoRate() {_uniqueStorage()._repoRate = nil}

  ///Контрагент/Брокер.
  public var party: String {
    get {return _storage._party}
    set {_uniqueStorage()._party = newValue}
  }

  ///Дата расчётов в часовом поясе UTC.
  public var clearValueDate_p: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._clearValueDate_p ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._clearValueDate_p = newValue}
  }
  /// Returns true if `clearValueDate_p` has been explicitly set.
  public var hasClearValueDate_p: Bool {return _storage._clearValueDate_p != nil}
  /// Clears the value of `clearValueDate_p`. Subsequent reads from it will return its default value.
  public mutating func clearClearValueDate_p() {_uniqueStorage()._clearValueDate_p = nil}

  ///Дата поставки в часовом поясе UTC.
  public var secValueDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._secValueDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._secValueDate = newValue}
  }
  /// Returns true if `secValueDate` has been explicitly set.
  public var hasSecValueDate: Bool {return _storage._secValueDate != nil}
  /// Clears the value of `secValueDate`. Subsequent reads from it will return its default value.
  public mutating func clearSecValueDate() {_uniqueStorage()._secValueDate = nil}

  ///Статус брокера.
  public var brokerStatus: String {
    get {return _storage._brokerStatus}
    set {_uniqueStorage()._brokerStatus = newValue}
  }

  ///Тип дог.
  public var separateAgreementType: String {
    get {return _storage._separateAgreementType}
    set {_uniqueStorage()._separateAgreementType = newValue}
  }

  ///Номер дог.
  public var separateAgreementNumber: String {
    get {return _storage._separateAgreementNumber}
    set {_uniqueStorage()._separateAgreementNumber = newValue}
  }

  ///Дата дог.
  public var separateAgreementDate: String {
    get {return _storage._separateAgreementDate}
    set {_uniqueStorage()._separateAgreementDate = newValue}
  }

  ///Тип расчёта по сделке.
  public var deliveryType: String {
    get {return _storage._deliveryType}
    set {_uniqueStorage()._deliveryType = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct GetDividendsForeignIssuerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: GetDividendsForeignIssuerRequest.OneOf_Payload? = nil

  ///Объект запроса формирования отчёта.
  public var generateDivForeignIssuerReport: GenerateDividendsForeignIssuerReportRequest {
    get {
      if case .generateDivForeignIssuerReport(let v)? = payload {return v}
      return GenerateDividendsForeignIssuerReportRequest()
    }
    set {payload = .generateDivForeignIssuerReport(newValue)}
  }

  ///Объект запроса сформированного отчёта.
  public var getDivForeignIssuerReport: GetDividendsForeignIssuerReportRequest {
    get {
      if case .getDivForeignIssuerReport(let v)? = payload {return v}
      return GetDividendsForeignIssuerReportRequest()
    }
    set {payload = .getDivForeignIssuerReport(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    ///Объект запроса формирования отчёта.
    case generateDivForeignIssuerReport(GenerateDividendsForeignIssuerReportRequest)
    ///Объект запроса сформированного отчёта.
    case getDivForeignIssuerReport(GetDividendsForeignIssuerReportRequest)

  #if !swift(>=4.1)
    public static func ==(lhs: GetDividendsForeignIssuerRequest.OneOf_Payload, rhs: GetDividendsForeignIssuerRequest.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.generateDivForeignIssuerReport, .generateDivForeignIssuerReport): return {
        guard case .generateDivForeignIssuerReport(let l) = lhs, case .generateDivForeignIssuerReport(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getDivForeignIssuerReport, .getDivForeignIssuerReport): return {
        guard case .getDivForeignIssuerReport(let l) = lhs, case .getDivForeignIssuerReport(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct GetDividendsForeignIssuerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: GetDividendsForeignIssuerResponse.OneOf_Payload? = nil

  ///Объект результата задачи запуска формирования отчёта.
  public var generateDivForeignIssuerReportResponse: GenerateDividendsForeignIssuerReportResponse {
    get {
      if case .generateDivForeignIssuerReportResponse(let v)? = payload {return v}
      return GenerateDividendsForeignIssuerReportResponse()
    }
    set {payload = .generateDivForeignIssuerReportResponse(newValue)}
  }

  ///Отчёт "Справка о доходах за пределами РФ".
  public var divForeignIssuerReport: GetDividendsForeignIssuerReportResponse {
    get {
      if case .divForeignIssuerReport(let v)? = payload {return v}
      return GetDividendsForeignIssuerReportResponse()
    }
    set {payload = .divForeignIssuerReport(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    ///Объект результата задачи запуска формирования отчёта.
    case generateDivForeignIssuerReportResponse(GenerateDividendsForeignIssuerReportResponse)
    ///Отчёт "Справка о доходах за пределами РФ".
    case divForeignIssuerReport(GetDividendsForeignIssuerReportResponse)

  #if !swift(>=4.1)
    public static func ==(lhs: GetDividendsForeignIssuerResponse.OneOf_Payload, rhs: GetDividendsForeignIssuerResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.generateDivForeignIssuerReportResponse, .generateDivForeignIssuerReportResponse): return {
        guard case .generateDivForeignIssuerReportResponse(let l) = lhs, case .generateDivForeignIssuerReportResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.divForeignIssuerReport, .divForeignIssuerReport): return {
        guard case .divForeignIssuerReport(let l) = lhs, case .divForeignIssuerReport(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

///Объект запроса формирования отчёта "Справка о доходах за пределами РФ".
public struct GenerateDividendsForeignIssuerReportRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор счёта клиента.
  public var accountID: String = String()

  ///Начало периода (по UTC).
  public var from: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  public var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  public mutating func clearFrom() {self._from = nil}

  ///Окончание периода (по UTC).
  public var to: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  public var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  public mutating func clearTo() {self._to = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Объект запроса сформированного отчёта "Справка о доходах за пределами РФ".
public struct GetDividendsForeignIssuerReportRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор задачи формирования отчёта.
  public var taskID: String = String()

  ///Номер страницы отчета (начинается с 0), значение по умолчанию: 0.
  public var page: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Объект результата задачи запуска формирования отчёта "Справка о доходах за пределами РФ".
public struct GenerateDividendsForeignIssuerReportResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор задачи формирования отчёта.
  public var taskID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GetDividendsForeignIssuerReportResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dividendsForeignIssuerReport: [DividendsForeignIssuerReport] = []

  ///Количество записей в отчете.
  public var itemsCount: Int32 = 0

  ///Количество страниц с данными отчета (начинается с 0).
  public var pagesCount: Int32 = 0

  ///Текущая страница (начинается с 0).
  public var page: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Отчёт "Справка о доходах за пределами РФ".
public struct DividendsForeignIssuerReport {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Дата фиксации реестра.
  public var recordDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._recordDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._recordDate = newValue}
  }
  /// Returns true if `recordDate` has been explicitly set.
  public var hasRecordDate: Bool {return _storage._recordDate != nil}
  /// Clears the value of `recordDate`. Subsequent reads from it will return its default value.
  public mutating func clearRecordDate() {_uniqueStorage()._recordDate = nil}

  ///Дата выплаты.
  public var paymentDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._paymentDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._paymentDate = newValue}
  }
  /// Returns true if `paymentDate` has been explicitly set.
  public var hasPaymentDate: Bool {return _storage._paymentDate != nil}
  /// Clears the value of `paymentDate`. Subsequent reads from it will return its default value.
  public mutating func clearPaymentDate() {_uniqueStorage()._paymentDate = nil}

  ///Наименование ценной бумаги.
  public var securityName: String {
    get {return _storage._securityName}
    set {_uniqueStorage()._securityName = newValue}
  }

  ///ISIN-идентификатор ценной бумаги.
  public var isin: String {
    get {return _storage._isin}
    set {_uniqueStorage()._isin = newValue}
  }

  ///Страна эмитента. Для депозитарных расписок указывается страна эмитента базового актива.
  public var issuerCountry: String {
    get {return _storage._issuerCountry}
    set {_uniqueStorage()._issuerCountry = newValue}
  }

  ///Количество ценных бумаг.
  public var quantity: Int64 {
    get {return _storage._quantity}
    set {_uniqueStorage()._quantity = newValue}
  }

  ///Выплаты на одну бумагу
  public var dividend: Quotation {
    get {return _storage._dividend ?? Quotation()}
    set {_uniqueStorage()._dividend = newValue}
  }
  /// Returns true if `dividend` has been explicitly set.
  public var hasDividend: Bool {return _storage._dividend != nil}
  /// Clears the value of `dividend`. Subsequent reads from it will return its default value.
  public mutating func clearDividend() {_uniqueStorage()._dividend = nil}

  ///Комиссия внешних платёжных агентов.
  public var externalCommission: Quotation {
    get {return _storage._externalCommission ?? Quotation()}
    set {_uniqueStorage()._externalCommission = newValue}
  }
  /// Returns true if `externalCommission` has been explicitly set.
  public var hasExternalCommission: Bool {return _storage._externalCommission != nil}
  /// Clears the value of `externalCommission`. Subsequent reads from it will return its default value.
  public mutating func clearExternalCommission() {_uniqueStorage()._externalCommission = nil}

  ///Сумма до удержания налога.
  public var dividendGross: Quotation {
    get {return _storage._dividendGross ?? Quotation()}
    set {_uniqueStorage()._dividendGross = newValue}
  }
  /// Returns true if `dividendGross` has been explicitly set.
  public var hasDividendGross: Bool {return _storage._dividendGross != nil}
  /// Clears the value of `dividendGross`. Subsequent reads from it will return its default value.
  public mutating func clearDividendGross() {_uniqueStorage()._dividendGross = nil}

  ///Сумма налога, удержанного агентом.
  public var tax: Quotation {
    get {return _storage._tax ?? Quotation()}
    set {_uniqueStorage()._tax = newValue}
  }
  /// Returns true if `tax` has been explicitly set.
  public var hasTax: Bool {return _storage._tax != nil}
  /// Clears the value of `tax`. Subsequent reads from it will return its default value.
  public mutating func clearTax() {_uniqueStorage()._tax = nil}

  ///Итоговая сумма выплаты.
  public var dividendAmount: Quotation {
    get {return _storage._dividendAmount ?? Quotation()}
    set {_uniqueStorage()._dividendAmount = newValue}
  }
  /// Returns true if `dividendAmount` has been explicitly set.
  public var hasDividendAmount: Bool {return _storage._dividendAmount != nil}
  /// Clears the value of `dividendAmount`. Subsequent reads from it will return its default value.
  public mutating func clearDividendAmount() {_uniqueStorage()._dividendAmount = nil}

  ///Валюта.
  public var currency: String {
    get {return _storage._currency}
    set {_uniqueStorage()._currency = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Запрос установки stream-соединения.
public struct PortfolioStreamRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив идентификаторов счётов пользователя
  public var accounts: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Информация по позициям и доходностям портфелей.
public struct PortfolioStreamResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: PortfolioStreamResponse.OneOf_Payload? = nil

  ///Объект результата подписки.
  public var subscriptions: PortfolioSubscriptionResult {
    get {
      if case .subscriptions(let v)? = payload {return v}
      return PortfolioSubscriptionResult()
    }
    set {payload = .subscriptions(newValue)}
  }

  ///Объект стриминга портфеля.
  public var portfolio: PortfolioResponse {
    get {
      if case .portfolio(let v)? = payload {return v}
      return PortfolioResponse()
    }
    set {payload = .portfolio(newValue)}
  }

  ///Проверка активности стрима.
  public var ping: Ping {
    get {
      if case .ping(let v)? = payload {return v}
      return Ping()
    }
    set {payload = .ping(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    ///Объект результата подписки.
    case subscriptions(PortfolioSubscriptionResult)
    ///Объект стриминга портфеля.
    case portfolio(PortfolioResponse)
    ///Проверка активности стрима.
    case ping(Ping)

  #if !swift(>=4.1)
    public static func ==(lhs: PortfolioStreamResponse.OneOf_Payload, rhs: PortfolioStreamResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.subscriptions, .subscriptions): return {
        guard case .subscriptions(let l) = lhs, case .subscriptions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.portfolio, .portfolio): return {
        guard case .portfolio(let l) = lhs, case .portfolio(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ping, .ping): return {
        guard case .ping(let l) = lhs, case .ping(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

///Объект результата подписки.
public struct PortfolioSubscriptionResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив счетов клиента.
  public var accounts: [AccountSubscriptionStatus] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Счет клиента.
public struct AccountSubscriptionStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор счёта
  public var accountID: String = String()

  ///Результат подписки.
  public var subscriptionStatus: PortfolioSubscriptionStatus = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос списка операций по счёту с пагинацией.
public struct GetOperationsByCursorRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор счёта клиента. Обязательный параметр для данного метода, остальные параметры опциональны.
  public var accountID: String = String()

  ///Идентификатор инструмента (Figi инструмента или uid инструмента)
  public var instrumentID: String = String()

  ///Начало периода (по UTC).
  public var from: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  public var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  public mutating func clearFrom() {self._from = nil}

  ///Окончание периода (по UTC).
  public var to: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  public var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  public mutating func clearTo() {self._to = nil}

  ///Идентификатор элемента, с которого начать формировать ответ.
  public var cursor: String = String()

  ///Лимит количества операций. По умолчанию устанавливается значение **100**, максимальное значение 1000.
  public var limit: Int32 = 0

  ///Тип операции. Принимает значение из списка OperationType.
  public var operationTypes: [OperationType] = []

  ///Статус запрашиваемых операций, возможные значения указаны в OperationState.
  public var state: OperationState = .unspecified

  ///Флаг возвращать ли комиссии, по умолчанию false
  public var withoutCommissions: Bool = false

  ///Флаг получения ответа без массива сделок.
  public var withoutTrades: Bool = false

  ///Флаг не показывать overnight операций.
  public var withoutOvernights: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Список операций по счёту с пагинацией.
public struct GetOperationsByCursorResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Признак, есть ли следующий элемент.
  public var hasNext_p: Bool = false

  ///Следующий курсор.
  public var nextCursor: String = String()

  ///Список операций.
  public var items: [OperationItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Данные об операции.
public struct OperationItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Курсор.
  public var cursor: String {
    get {return _storage._cursor}
    set {_uniqueStorage()._cursor = newValue}
  }

  ///Номер счета клиента.
  public var brokerAccountID: String {
    get {return _storage._brokerAccountID}
    set {_uniqueStorage()._brokerAccountID = newValue}
  }

  ///Номер поручения.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  ///Номер родительского поручения.
  public var parentOperationID: String {
    get {return _storage._parentOperationID}
    set {_uniqueStorage()._parentOperationID = newValue}
  }

  ///Название операции.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  ///Дата поручения.
  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return _storage._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {_uniqueStorage()._date = nil}

  ///Тип операции.
  public var type: OperationType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  ///Описание операции.
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  ///Статус поручения.
  public var state: OperationState {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  ///Уникальный идентификатор инструмента.
  public var instrumentUid: String {
    get {return _storage._instrumentUid}
    set {_uniqueStorage()._instrumentUid = newValue}
  }

  ///Figi.
  public var figi: String {
    get {return _storage._figi}
    set {_uniqueStorage()._figi = newValue}
  }

  ///Тип инструмента.
  public var instrumentType: String {
    get {return _storage._instrumentType}
    set {_uniqueStorage()._instrumentType = newValue}
  }

  ///Тип инструмента.
  public var instrumentKind: InstrumentType {
    get {return _storage._instrumentKind}
    set {_uniqueStorage()._instrumentKind = newValue}
  }

  ///Сумма операции.
  public var payment: MoneyValue {
    get {return _storage._payment ?? MoneyValue()}
    set {_uniqueStorage()._payment = newValue}
  }
  /// Returns true if `payment` has been explicitly set.
  public var hasPayment: Bool {return _storage._payment != nil}
  /// Clears the value of `payment`. Subsequent reads from it will return its default value.
  public mutating func clearPayment() {_uniqueStorage()._payment = nil}

  ///Цена операции за 1 инструмент.
  public var price: MoneyValue {
    get {return _storage._price ?? MoneyValue()}
    set {_uniqueStorage()._price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  public var hasPrice: Bool {return _storage._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  public mutating func clearPrice() {_uniqueStorage()._price = nil}

  ///Комиссия.
  public var commission: MoneyValue {
    get {return _storage._commission ?? MoneyValue()}
    set {_uniqueStorage()._commission = newValue}
  }
  /// Returns true if `commission` has been explicitly set.
  public var hasCommission: Bool {return _storage._commission != nil}
  /// Clears the value of `commission`. Subsequent reads from it will return its default value.
  public mutating func clearCommission() {_uniqueStorage()._commission = nil}

  ///Доходность.
  public var yield: MoneyValue {
    get {return _storage._yield ?? MoneyValue()}
    set {_uniqueStorage()._yield = newValue}
  }
  /// Returns true if `yield` has been explicitly set.
  public var hasYield: Bool {return _storage._yield != nil}
  /// Clears the value of `yield`. Subsequent reads from it will return its default value.
  public mutating func clearYield() {_uniqueStorage()._yield = nil}

  ///Относительная доходность.
  public var yieldRelative: Quotation {
    get {return _storage._yieldRelative ?? Quotation()}
    set {_uniqueStorage()._yieldRelative = newValue}
  }
  /// Returns true if `yieldRelative` has been explicitly set.
  public var hasYieldRelative: Bool {return _storage._yieldRelative != nil}
  /// Clears the value of `yieldRelative`. Subsequent reads from it will return its default value.
  public mutating func clearYieldRelative() {_uniqueStorage()._yieldRelative = nil}

  ///Накопленный купонный доход.
  public var accruedInt: MoneyValue {
    get {return _storage._accruedInt ?? MoneyValue()}
    set {_uniqueStorage()._accruedInt = newValue}
  }
  /// Returns true if `accruedInt` has been explicitly set.
  public var hasAccruedInt: Bool {return _storage._accruedInt != nil}
  /// Clears the value of `accruedInt`. Subsequent reads from it will return its default value.
  public mutating func clearAccruedInt() {_uniqueStorage()._accruedInt = nil}

  ///Количество единиц инструмента.
  public var quantity: Int64 {
    get {return _storage._quantity}
    set {_uniqueStorage()._quantity = newValue}
  }

  ///Неисполненный остаток по сделке.
  public var quantityRest: Int64 {
    get {return _storage._quantityRest}
    set {_uniqueStorage()._quantityRest = newValue}
  }

  ///Исполненный остаток.
  public var quantityDone: Int64 {
    get {return _storage._quantityDone}
    set {_uniqueStorage()._quantityDone = newValue}
  }

  ///Дата и время снятия заявки.
  public var cancelDateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._cancelDateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._cancelDateTime = newValue}
  }
  /// Returns true if `cancelDateTime` has been explicitly set.
  public var hasCancelDateTime: Bool {return _storage._cancelDateTime != nil}
  /// Clears the value of `cancelDateTime`. Subsequent reads from it will return its default value.
  public mutating func clearCancelDateTime() {_uniqueStorage()._cancelDateTime = nil}

  ///Причина отмены операции.
  public var cancelReason: String {
    get {return _storage._cancelReason}
    set {_uniqueStorage()._cancelReason = newValue}
  }

  ///Массив сделок.
  public var tradesInfo: OperationItemTrades {
    get {return _storage._tradesInfo ?? OperationItemTrades()}
    set {_uniqueStorage()._tradesInfo = newValue}
  }
  /// Returns true if `tradesInfo` has been explicitly set.
  public var hasTradesInfo: Bool {return _storage._tradesInfo != nil}
  /// Clears the value of `tradesInfo`. Subsequent reads from it will return its default value.
  public mutating func clearTradesInfo() {_uniqueStorage()._tradesInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Массив с информацией о сделках.
public struct OperationItemTrades {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var trades: [OperationItemTrade] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Сделка по операции.
public struct OperationItemTrade {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Номер сделки
  public var num: String = String()

  ///Дата сделки
  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {self._date = nil}

  ///Количество в единицах.
  public var quantity: Int64 = 0

  ///Цена.
  public var price: MoneyValue {
    get {return _price ?? MoneyValue()}
    set {_price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  public var hasPrice: Bool {return self._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  public mutating func clearPrice() {self._price = nil}

  ///Доходность.
  public var yield: MoneyValue {
    get {return _yield ?? MoneyValue()}
    set {_yield = newValue}
  }
  /// Returns true if `yield` has been explicitly set.
  public var hasYield: Bool {return self._yield != nil}
  /// Clears the value of `yield`. Subsequent reads from it will return its default value.
  public mutating func clearYield() {self._yield = nil}

  ///Относительная доходность.
  public var yieldRelative: Quotation {
    get {return _yieldRelative ?? Quotation()}
    set {_yieldRelative = newValue}
  }
  /// Returns true if `yieldRelative` has been explicitly set.
  public var hasYieldRelative: Bool {return self._yieldRelative != nil}
  /// Clears the value of `yieldRelative`. Subsequent reads from it will return its default value.
  public mutating func clearYieldRelative() {self._yieldRelative = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _price: MoneyValue? = nil
  fileprivate var _yield: MoneyValue? = nil
  fileprivate var _yieldRelative: Quotation? = nil
}

///Запрос установки stream-соединения позиций.
public struct PositionsStreamRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив идентификаторов счётов пользователя
  public var accounts: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Информация по изменению позиций портфеля.
public struct PositionsStreamResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: PositionsStreamResponse.OneOf_Payload? = nil

  ///Объект результата подписки.
  public var subscriptions: PositionsSubscriptionResult {
    get {
      if case .subscriptions(let v)? = payload {return v}
      return PositionsSubscriptionResult()
    }
    set {payload = .subscriptions(newValue)}
  }

  ///Объект стриминга позиций.
  public var position: PositionData {
    get {
      if case .position(let v)? = payload {return v}
      return PositionData()
    }
    set {payload = .position(newValue)}
  }

  ///Проверка активности стрима.
  public var ping: Ping {
    get {
      if case .ping(let v)? = payload {return v}
      return Ping()
    }
    set {payload = .ping(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    ///Объект результата подписки.
    case subscriptions(PositionsSubscriptionResult)
    ///Объект стриминга позиций.
    case position(PositionData)
    ///Проверка активности стрима.
    case ping(Ping)

  #if !swift(>=4.1)
    public static func ==(lhs: PositionsStreamResponse.OneOf_Payload, rhs: PositionsStreamResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.subscriptions, .subscriptions): return {
        guard case .subscriptions(let l) = lhs, case .subscriptions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.position, .position): return {
        guard case .position(let l) = lhs, case .position(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ping, .ping): return {
        guard case .ping(let l) = lhs, case .ping(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

///Объект результата подписки.
public struct PositionsSubscriptionResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив счетов клиента.
  public var accounts: [PositionsSubscriptionStatus] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Счет клиента.
public struct PositionsSubscriptionStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор счёта
  public var accountID: String = String()

  ///Результат подписки.
  public var subscriptionStatus: PositionsAccountSubscriptionStatus = .positionsSubscriptionStatusUnspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Данные о позиции портфеля.
public struct PositionData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор счёта.
  public var accountID: String = String()

  ///Массив валютных позиций портфеля.
  public var money: [PositionsMoney] = []

  ///Список ценно-бумажных позиций портфеля.
  public var securities: [PositionsSecurities] = []

  ///Список фьючерсов портфеля.
  public var futures: [PositionsFutures] = []

  ///Список опционов портфеля.
  public var options: [PositionsOptions] = []

  ///Дата и время операции в формате UTC.
  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {self._date = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Валютная позиция портфеля.
public struct PositionsMoney {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Доступное количество валютный позиций.
  public var availableValue: MoneyValue {
    get {return _availableValue ?? MoneyValue()}
    set {_availableValue = newValue}
  }
  /// Returns true if `availableValue` has been explicitly set.
  public var hasAvailableValue: Bool {return self._availableValue != nil}
  /// Clears the value of `availableValue`. Subsequent reads from it will return its default value.
  public mutating func clearAvailableValue() {self._availableValue = nil}

  ///Заблокированное количество валютный позиций.
  public var blockedValue: MoneyValue {
    get {return _blockedValue ?? MoneyValue()}
    set {_blockedValue = newValue}
  }
  /// Returns true if `blockedValue` has been explicitly set.
  public var hasBlockedValue: Bool {return self._blockedValue != nil}
  /// Clears the value of `blockedValue`. Subsequent reads from it will return its default value.
  public mutating func clearBlockedValue() {self._blockedValue = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _availableValue: MoneyValue? = nil
  fileprivate var _blockedValue: MoneyValue? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tinkoff.public.invest.api.contract.v1"

extension OperationState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPERATION_STATE_UNSPECIFIED"),
    1: .same(proto: "OPERATION_STATE_EXECUTED"),
    2: .same(proto: "OPERATION_STATE_CANCELED"),
    3: .same(proto: "OPERATION_STATE_PROGRESS"),
  ]
}

extension OperationType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPERATION_TYPE_UNSPECIFIED"),
    1: .same(proto: "OPERATION_TYPE_INPUT"),
    2: .same(proto: "OPERATION_TYPE_BOND_TAX"),
    3: .same(proto: "OPERATION_TYPE_OUTPUT_SECURITIES"),
    4: .same(proto: "OPERATION_TYPE_OVERNIGHT"),
    5: .same(proto: "OPERATION_TYPE_TAX"),
    6: .same(proto: "OPERATION_TYPE_BOND_REPAYMENT_FULL"),
    7: .same(proto: "OPERATION_TYPE_SELL_CARD"),
    8: .same(proto: "OPERATION_TYPE_DIVIDEND_TAX"),
    9: .same(proto: "OPERATION_TYPE_OUTPUT"),
    10: .same(proto: "OPERATION_TYPE_BOND_REPAYMENT"),
    11: .same(proto: "OPERATION_TYPE_TAX_CORRECTION"),
    12: .same(proto: "OPERATION_TYPE_SERVICE_FEE"),
    13: .same(proto: "OPERATION_TYPE_BENEFIT_TAX"),
    14: .same(proto: "OPERATION_TYPE_MARGIN_FEE"),
    15: .same(proto: "OPERATION_TYPE_BUY"),
    16: .same(proto: "OPERATION_TYPE_BUY_CARD"),
    17: .same(proto: "OPERATION_TYPE_INPUT_SECURITIES"),
    18: .same(proto: "OPERATION_TYPE_SELL_MARGIN"),
    19: .same(proto: "OPERATION_TYPE_BROKER_FEE"),
    20: .same(proto: "OPERATION_TYPE_BUY_MARGIN"),
    21: .same(proto: "OPERATION_TYPE_DIVIDEND"),
    22: .same(proto: "OPERATION_TYPE_SELL"),
    23: .same(proto: "OPERATION_TYPE_COUPON"),
    24: .same(proto: "OPERATION_TYPE_SUCCESS_FEE"),
    25: .same(proto: "OPERATION_TYPE_DIVIDEND_TRANSFER"),
    26: .same(proto: "OPERATION_TYPE_ACCRUING_VARMARGIN"),
    27: .same(proto: "OPERATION_TYPE_WRITING_OFF_VARMARGIN"),
    28: .same(proto: "OPERATION_TYPE_DELIVERY_BUY"),
    29: .same(proto: "OPERATION_TYPE_DELIVERY_SELL"),
    30: .same(proto: "OPERATION_TYPE_TRACK_MFEE"),
    31: .same(proto: "OPERATION_TYPE_TRACK_PFEE"),
    32: .same(proto: "OPERATION_TYPE_TAX_PROGRESSIVE"),
    33: .same(proto: "OPERATION_TYPE_BOND_TAX_PROGRESSIVE"),
    34: .same(proto: "OPERATION_TYPE_DIVIDEND_TAX_PROGRESSIVE"),
    35: .same(proto: "OPERATION_TYPE_BENEFIT_TAX_PROGRESSIVE"),
    36: .same(proto: "OPERATION_TYPE_TAX_CORRECTION_PROGRESSIVE"),
    37: .same(proto: "OPERATION_TYPE_TAX_REPO_PROGRESSIVE"),
    38: .same(proto: "OPERATION_TYPE_TAX_REPO"),
    39: .same(proto: "OPERATION_TYPE_TAX_REPO_HOLD"),
    40: .same(proto: "OPERATION_TYPE_TAX_REPO_REFUND"),
    41: .same(proto: "OPERATION_TYPE_TAX_REPO_HOLD_PROGRESSIVE"),
    42: .same(proto: "OPERATION_TYPE_TAX_REPO_REFUND_PROGRESSIVE"),
    43: .same(proto: "OPERATION_TYPE_DIV_EXT"),
    44: .same(proto: "OPERATION_TYPE_TAX_CORRECTION_COUPON"),
    45: .same(proto: "OPERATION_TYPE_CASH_FEE"),
    46: .same(proto: "OPERATION_TYPE_OUT_FEE"),
    47: .same(proto: "OPERATION_TYPE_OUT_STAMP_DUTY"),
  ]
}

extension PortfolioSubscriptionStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PORTFOLIO_SUBSCRIPTION_STATUS_UNSPECIFIED"),
    1: .same(proto: "PORTFOLIO_SUBSCRIPTION_STATUS_SUCCESS"),
    2: .same(proto: "PORTFOLIO_SUBSCRIPTION_STATUS_ACCOUNT_NOT_FOUND"),
    3: .same(proto: "PORTFOLIO_SUBSCRIPTION_STATUS_INTERNAL_ERROR"),
  ]
}

extension InstrumentType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INSTRUMENT_TYPE_UNSPECIFIED"),
    1: .same(proto: "INSTRUMENT_TYPE_BOND"),
    2: .same(proto: "INSTRUMENT_TYPE_SHARE"),
    3: .same(proto: "INSTRUMENT_TYPE_CURRENCY"),
    4: .same(proto: "INSTRUMENT_TYPE_ETF"),
    5: .same(proto: "INSTRUMENT_TYPE_FUTURES"),
    6: .same(proto: "INSTRUMENT_TYPE_SP"),
    7: .same(proto: "INSTRUMENT_TYPE_OPTION"),
  ]
}

extension PositionsAccountSubscriptionStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "POSITIONS_SUBSCRIPTION_STATUS_UNSPECIFIED"),
    1: .same(proto: "POSITIONS_SUBSCRIPTION_STATUS_SUCCESS"),
    2: .same(proto: "POSITIONS_SUBSCRIPTION_STATUS_ACCOUNT_NOT_FOUND"),
    3: .same(proto: "POSITIONS_SUBSCRIPTION_STATUS_INTERNAL_ERROR"),
  ]
}

extension OperationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OperationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
    4: .same(proto: "state"),
    5: .same(proto: "figi"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 4)
    }
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OperationsRequest, rhs: OperationsRequest) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs.state != rhs.state {return false}
    if lhs.figi != rhs.figi {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OperationsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OperationsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.operations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.operations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.operations, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OperationsResponse, rhs: OperationsResponse) -> Bool {
    if lhs.operations != rhs.operations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Operation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Operation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "parent_operation_id"),
    3: .same(proto: "currency"),
    4: .same(proto: "payment"),
    5: .same(proto: "price"),
    6: .same(proto: "state"),
    7: .same(proto: "quantity"),
    8: .standard(proto: "quantity_rest"),
    9: .same(proto: "figi"),
    10: .standard(proto: "instrument_type"),
    11: .same(proto: "date"),
    12: .same(proto: "type"),
    13: .standard(proto: "operation_type"),
    14: .same(proto: "trades"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _parentOperationID: String = String()
    var _currency: String = String()
    var _payment: MoneyValue? = nil
    var _price: MoneyValue? = nil
    var _state: OperationState = .unspecified
    var _quantity: Int64 = 0
    var _quantityRest: Int64 = 0
    var _figi: String = String()
    var _instrumentType: String = String()
    var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _type: String = String()
    var _operationType: OperationType = .unspecified
    var _trades: [OperationTrade] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _parentOperationID = source._parentOperationID
      _currency = source._currency
      _payment = source._payment
      _price = source._price
      _state = source._state
      _quantity = source._quantity
      _quantityRest = source._quantityRest
      _figi = source._figi
      _instrumentType = source._instrumentType
      _date = source._date
      _type = source._type
      _operationType = source._operationType
      _trades = source._trades
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._parentOperationID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._currency) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._payment) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._price) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 7: try { try decoder.decodeSingularInt64Field(value: &_storage._quantity) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._quantityRest) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._figi) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._instrumentType) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._date) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._type) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._operationType) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._trades) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._parentOperationID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._parentOperationID, fieldNumber: 2)
      }
      if !_storage._currency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currency, fieldNumber: 3)
      }
      try { if let v = _storage._payment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._price {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 6)
      }
      if _storage._quantity != 0 {
        try visitor.visitSingularInt64Field(value: _storage._quantity, fieldNumber: 7)
      }
      if _storage._quantityRest != 0 {
        try visitor.visitSingularInt64Field(value: _storage._quantityRest, fieldNumber: 8)
      }
      if !_storage._figi.isEmpty {
        try visitor.visitSingularStringField(value: _storage._figi, fieldNumber: 9)
      }
      if !_storage._instrumentType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._instrumentType, fieldNumber: 10)
      }
      try { if let v = _storage._date {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if !_storage._type.isEmpty {
        try visitor.visitSingularStringField(value: _storage._type, fieldNumber: 12)
      }
      if _storage._operationType != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._operationType, fieldNumber: 13)
      }
      if !_storage._trades.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._trades, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Operation, rhs: Operation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._parentOperationID != rhs_storage._parentOperationID {return false}
        if _storage._currency != rhs_storage._currency {return false}
        if _storage._payment != rhs_storage._payment {return false}
        if _storage._price != rhs_storage._price {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._quantity != rhs_storage._quantity {return false}
        if _storage._quantityRest != rhs_storage._quantityRest {return false}
        if _storage._figi != rhs_storage._figi {return false}
        if _storage._instrumentType != rhs_storage._instrumentType {return false}
        if _storage._date != rhs_storage._date {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._operationType != rhs_storage._operationType {return false}
        if _storage._trades != rhs_storage._trades {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OperationTrade: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OperationTrade"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trade_id"),
    2: .standard(proto: "date_time"),
    3: .same(proto: "quantity"),
    4: .same(proto: "price"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tradeID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._dateTime) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.quantity) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._price) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.tradeID.isEmpty {
      try visitor.visitSingularStringField(value: self.tradeID, fieldNumber: 1)
    }
    try { if let v = self._dateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.quantity != 0 {
      try visitor.visitSingularInt64Field(value: self.quantity, fieldNumber: 3)
    }
    try { if let v = self._price {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OperationTrade, rhs: OperationTrade) -> Bool {
    if lhs.tradeID != rhs.tradeID {return false}
    if lhs._dateTime != rhs._dateTime {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs._price != rhs._price {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PortfolioRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PortfolioRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PortfolioRequest, rhs: PortfolioRequest) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PortfolioResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PortfolioResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_amount_shares"),
    2: .standard(proto: "total_amount_bonds"),
    3: .standard(proto: "total_amount_etf"),
    4: .standard(proto: "total_amount_currencies"),
    5: .standard(proto: "total_amount_futures"),
    6: .standard(proto: "expected_yield"),
    7: .same(proto: "positions"),
    8: .standard(proto: "account_id"),
  ]

  fileprivate class _StorageClass {
    var _totalAmountShares: MoneyValue? = nil
    var _totalAmountBonds: MoneyValue? = nil
    var _totalAmountEtf: MoneyValue? = nil
    var _totalAmountCurrencies: MoneyValue? = nil
    var _totalAmountFutures: MoneyValue? = nil
    var _expectedYield: Quotation? = nil
    var _positions: [PortfolioPosition] = []
    var _accountID: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _totalAmountShares = source._totalAmountShares
      _totalAmountBonds = source._totalAmountBonds
      _totalAmountEtf = source._totalAmountEtf
      _totalAmountCurrencies = source._totalAmountCurrencies
      _totalAmountFutures = source._totalAmountFutures
      _expectedYield = source._expectedYield
      _positions = source._positions
      _accountID = source._accountID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._totalAmountShares) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._totalAmountBonds) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._totalAmountEtf) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._totalAmountCurrencies) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._totalAmountFutures) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._expectedYield) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._positions) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._accountID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._totalAmountShares {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._totalAmountBonds {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._totalAmountEtf {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._totalAmountCurrencies {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._totalAmountFutures {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._expectedYield {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._positions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._positions, fieldNumber: 7)
      }
      if !_storage._accountID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._accountID, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PortfolioResponse, rhs: PortfolioResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._totalAmountShares != rhs_storage._totalAmountShares {return false}
        if _storage._totalAmountBonds != rhs_storage._totalAmountBonds {return false}
        if _storage._totalAmountEtf != rhs_storage._totalAmountEtf {return false}
        if _storage._totalAmountCurrencies != rhs_storage._totalAmountCurrencies {return false}
        if _storage._totalAmountFutures != rhs_storage._totalAmountFutures {return false}
        if _storage._expectedYield != rhs_storage._expectedYield {return false}
        if _storage._positions != rhs_storage._positions {return false}
        if _storage._accountID != rhs_storage._accountID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PositionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PositionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PositionsRequest, rhs: PositionsRequest) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PositionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PositionsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "money"),
    2: .same(proto: "blocked"),
    3: .same(proto: "securities"),
    4: .standard(proto: "limits_loading_in_progress"),
    5: .same(proto: "futures"),
    6: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.money) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.blocked) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.securities) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.limitsLoadingInProgress) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.futures) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.money.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.money, fieldNumber: 1)
    }
    if !self.blocked.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blocked, fieldNumber: 2)
    }
    if !self.securities.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.securities, fieldNumber: 3)
    }
    if self.limitsLoadingInProgress != false {
      try visitor.visitSingularBoolField(value: self.limitsLoadingInProgress, fieldNumber: 4)
    }
    if !self.futures.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.futures, fieldNumber: 5)
    }
    if !self.options.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.options, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PositionsResponse, rhs: PositionsResponse) -> Bool {
    if lhs.money != rhs.money {return false}
    if lhs.blocked != rhs.blocked {return false}
    if lhs.securities != rhs.securities {return false}
    if lhs.limitsLoadingInProgress != rhs.limitsLoadingInProgress {return false}
    if lhs.futures != rhs.futures {return false}
    if lhs.options != rhs.options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WithdrawLimitsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WithdrawLimitsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WithdrawLimitsRequest, rhs: WithdrawLimitsRequest) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WithdrawLimitsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WithdrawLimitsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "money"),
    2: .same(proto: "blocked"),
    3: .standard(proto: "blocked_guarantee"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.money) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.blocked) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.blockedGuarantee) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.money.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.money, fieldNumber: 1)
    }
    if !self.blocked.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blocked, fieldNumber: 2)
    }
    if !self.blockedGuarantee.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blockedGuarantee, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WithdrawLimitsResponse, rhs: WithdrawLimitsResponse) -> Bool {
    if lhs.money != rhs.money {return false}
    if lhs.blocked != rhs.blocked {return false}
    if lhs.blockedGuarantee != rhs.blockedGuarantee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PortfolioPosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PortfolioPosition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "instrument_type"),
    3: .same(proto: "quantity"),
    4: .standard(proto: "average_position_price"),
    5: .standard(proto: "expected_yield"),
    6: .standard(proto: "current_nkd"),
    7: .standard(proto: "average_position_price_pt"),
    8: .standard(proto: "current_price"),
    9: .standard(proto: "average_position_price_fifo"),
    10: .standard(proto: "quantity_lots"),
    21: .same(proto: "blocked"),
  ]

  fileprivate class _StorageClass {
    var _figi: String = String()
    var _instrumentType: String = String()
    var _quantity: Quotation? = nil
    var _averagePositionPrice: MoneyValue? = nil
    var _expectedYield: Quotation? = nil
    var _currentNkd: MoneyValue? = nil
    var _averagePositionPricePt: Quotation? = nil
    var _currentPrice: MoneyValue? = nil
    var _averagePositionPriceFifo: MoneyValue? = nil
    var _quantityLots: Quotation? = nil
    var _blocked: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _figi = source._figi
      _instrumentType = source._instrumentType
      _quantity = source._quantity
      _averagePositionPrice = source._averagePositionPrice
      _expectedYield = source._expectedYield
      _currentNkd = source._currentNkd
      _averagePositionPricePt = source._averagePositionPricePt
      _currentPrice = source._currentPrice
      _averagePositionPriceFifo = source._averagePositionPriceFifo
      _quantityLots = source._quantityLots
      _blocked = source._blocked
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._figi) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._instrumentType) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._quantity) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._averagePositionPrice) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._expectedYield) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._currentNkd) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._averagePositionPricePt) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._currentPrice) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._averagePositionPriceFifo) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._quantityLots) }()
        case 21: try { try decoder.decodeSingularBoolField(value: &_storage._blocked) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._figi.isEmpty {
        try visitor.visitSingularStringField(value: _storage._figi, fieldNumber: 1)
      }
      if !_storage._instrumentType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._instrumentType, fieldNumber: 2)
      }
      try { if let v = _storage._quantity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._averagePositionPrice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._expectedYield {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._currentNkd {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._averagePositionPricePt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._currentPrice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._averagePositionPriceFifo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._quantityLots {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if _storage._blocked != false {
        try visitor.visitSingularBoolField(value: _storage._blocked, fieldNumber: 21)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PortfolioPosition, rhs: PortfolioPosition) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._figi != rhs_storage._figi {return false}
        if _storage._instrumentType != rhs_storage._instrumentType {return false}
        if _storage._quantity != rhs_storage._quantity {return false}
        if _storage._averagePositionPrice != rhs_storage._averagePositionPrice {return false}
        if _storage._expectedYield != rhs_storage._expectedYield {return false}
        if _storage._currentNkd != rhs_storage._currentNkd {return false}
        if _storage._averagePositionPricePt != rhs_storage._averagePositionPricePt {return false}
        if _storage._currentPrice != rhs_storage._currentPrice {return false}
        if _storage._averagePositionPriceFifo != rhs_storage._averagePositionPriceFifo {return false}
        if _storage._quantityLots != rhs_storage._quantityLots {return false}
        if _storage._blocked != rhs_storage._blocked {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PositionsSecurities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PositionsSecurities"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "blocked"),
    3: .same(proto: "balance"),
    4: .standard(proto: "position_uid"),
    5: .standard(proto: "instrument_uid"),
    11: .standard(proto: "exchange_blocked"),
    16: .standard(proto: "instrument_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.blocked) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.balance) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.positionUid) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.exchangeBlocked) }()
      case 16: try { try decoder.decodeSingularStringField(value: &self.instrumentType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.blocked != 0 {
      try visitor.visitSingularInt64Field(value: self.blocked, fieldNumber: 2)
    }
    if self.balance != 0 {
      try visitor.visitSingularInt64Field(value: self.balance, fieldNumber: 3)
    }
    if !self.positionUid.isEmpty {
      try visitor.visitSingularStringField(value: self.positionUid, fieldNumber: 4)
    }
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 5)
    }
    if self.exchangeBlocked != false {
      try visitor.visitSingularBoolField(value: self.exchangeBlocked, fieldNumber: 11)
    }
    if !self.instrumentType.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentType, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PositionsSecurities, rhs: PositionsSecurities) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.blocked != rhs.blocked {return false}
    if lhs.balance != rhs.balance {return false}
    if lhs.positionUid != rhs.positionUid {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.exchangeBlocked != rhs.exchangeBlocked {return false}
    if lhs.instrumentType != rhs.instrumentType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PositionsFutures: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PositionsFutures"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "blocked"),
    3: .same(proto: "balance"),
    4: .standard(proto: "position_uid"),
    5: .standard(proto: "instrument_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.blocked) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.balance) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.positionUid) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.blocked != 0 {
      try visitor.visitSingularInt64Field(value: self.blocked, fieldNumber: 2)
    }
    if self.balance != 0 {
      try visitor.visitSingularInt64Field(value: self.balance, fieldNumber: 3)
    }
    if !self.positionUid.isEmpty {
      try visitor.visitSingularStringField(value: self.positionUid, fieldNumber: 4)
    }
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PositionsFutures, rhs: PositionsFutures) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.blocked != rhs.blocked {return false}
    if lhs.balance != rhs.balance {return false}
    if lhs.positionUid != rhs.positionUid {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PositionsOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PositionsOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "position_uid"),
    2: .standard(proto: "instrument_uid"),
    11: .same(proto: "blocked"),
    21: .same(proto: "balance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.positionUid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.blocked) }()
      case 21: try { try decoder.decodeSingularInt64Field(value: &self.balance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.positionUid.isEmpty {
      try visitor.visitSingularStringField(value: self.positionUid, fieldNumber: 1)
    }
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 2)
    }
    if self.blocked != 0 {
      try visitor.visitSingularInt64Field(value: self.blocked, fieldNumber: 11)
    }
    if self.balance != 0 {
      try visitor.visitSingularInt64Field(value: self.balance, fieldNumber: 21)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PositionsOptions, rhs: PositionsOptions) -> Bool {
    if lhs.positionUid != rhs.positionUid {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.blocked != rhs.blocked {return false}
    if lhs.balance != rhs.balance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BrokerReportRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BrokerReportRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "generate_broker_report_request"),
    2: .standard(proto: "get_broker_report_request"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: GenerateBrokerReportRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .generateBrokerReportRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .generateBrokerReportRequest(v)
        }
      }()
      case 2: try {
        var v: GetBrokerReportRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .getBrokerReportRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .getBrokerReportRequest(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .generateBrokerReportRequest?: try {
      guard case .generateBrokerReportRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .getBrokerReportRequest?: try {
      guard case .getBrokerReportRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BrokerReportRequest, rhs: BrokerReportRequest) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BrokerReportResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BrokerReportResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "generate_broker_report_response"),
    2: .standard(proto: "get_broker_report_response"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: GenerateBrokerReportResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .generateBrokerReportResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .generateBrokerReportResponse(v)
        }
      }()
      case 2: try {
        var v: GetBrokerReportResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .getBrokerReportResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .getBrokerReportResponse(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .generateBrokerReportResponse?: try {
      guard case .generateBrokerReportResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .getBrokerReportResponse?: try {
      guard case .getBrokerReportResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BrokerReportResponse, rhs: BrokerReportResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GenerateBrokerReportRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateBrokerReportRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GenerateBrokerReportRequest, rhs: GenerateBrokerReportRequest) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GenerateBrokerReportResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateBrokerReportResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "task_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.taskID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GenerateBrokerReportResponse, rhs: GenerateBrokerReportResponse) -> Bool {
    if lhs.taskID != rhs.taskID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetBrokerReportRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetBrokerReportRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "task_id"),
    2: .same(proto: "page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.taskID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.page) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 1)
    }
    if self.page != 0 {
      try visitor.visitSingularInt32Field(value: self.page, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetBrokerReportRequest, rhs: GetBrokerReportRequest) -> Bool {
    if lhs.taskID != rhs.taskID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetBrokerReportResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetBrokerReportResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "broker_report"),
    2: .same(proto: "itemsCount"),
    3: .same(proto: "pagesCount"),
    4: .same(proto: "page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.brokerReport) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.itemsCount) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pagesCount) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.page) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.brokerReport.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.brokerReport, fieldNumber: 1)
    }
    if self.itemsCount != 0 {
      try visitor.visitSingularInt32Field(value: self.itemsCount, fieldNumber: 2)
    }
    if self.pagesCount != 0 {
      try visitor.visitSingularInt32Field(value: self.pagesCount, fieldNumber: 3)
    }
    if self.page != 0 {
      try visitor.visitSingularInt32Field(value: self.page, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetBrokerReportResponse, rhs: GetBrokerReportResponse) -> Bool {
    if lhs.brokerReport != rhs.brokerReport {return false}
    if lhs.itemsCount != rhs.itemsCount {return false}
    if lhs.pagesCount != rhs.pagesCount {return false}
    if lhs.page != rhs.page {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BrokerReport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BrokerReport"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trade_id"),
    2: .standard(proto: "order_id"),
    3: .same(proto: "figi"),
    4: .standard(proto: "execute_sign"),
    5: .standard(proto: "trade_datetime"),
    6: .same(proto: "exchange"),
    7: .standard(proto: "class_code"),
    8: .same(proto: "direction"),
    9: .same(proto: "name"),
    10: .same(proto: "ticker"),
    11: .same(proto: "price"),
    12: .same(proto: "quantity"),
    13: .standard(proto: "order_amount"),
    14: .standard(proto: "aci_value"),
    15: .standard(proto: "total_order_amount"),
    16: .standard(proto: "broker_commission"),
    17: .standard(proto: "exchange_commission"),
    18: .standard(proto: "exchange_clearing_commission"),
    19: .standard(proto: "repo_rate"),
    20: .same(proto: "party"),
    21: .standard(proto: "clear_value_date"),
    22: .standard(proto: "sec_value_date"),
    23: .standard(proto: "broker_status"),
    24: .standard(proto: "separate_agreement_type"),
    25: .standard(proto: "separate_agreement_number"),
    26: .standard(proto: "separate_agreement_date"),
    27: .standard(proto: "delivery_type"),
  ]

  fileprivate class _StorageClass {
    var _tradeID: String = String()
    var _orderID: String = String()
    var _figi: String = String()
    var _executeSign: String = String()
    var _tradeDatetime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _exchange: String = String()
    var _classCode: String = String()
    var _direction: String = String()
    var _name: String = String()
    var _ticker: String = String()
    var _price: MoneyValue? = nil
    var _quantity: Int64 = 0
    var _orderAmount: MoneyValue? = nil
    var _aciValue: Quotation? = nil
    var _totalOrderAmount: MoneyValue? = nil
    var _brokerCommission: MoneyValue? = nil
    var _exchangeCommission: MoneyValue? = nil
    var _exchangeClearingCommission: MoneyValue? = nil
    var _repoRate: Quotation? = nil
    var _party: String = String()
    var _clearValueDate_p: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _secValueDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _brokerStatus: String = String()
    var _separateAgreementType: String = String()
    var _separateAgreementNumber: String = String()
    var _separateAgreementDate: String = String()
    var _deliveryType: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _tradeID = source._tradeID
      _orderID = source._orderID
      _figi = source._figi
      _executeSign = source._executeSign
      _tradeDatetime = source._tradeDatetime
      _exchange = source._exchange
      _classCode = source._classCode
      _direction = source._direction
      _name = source._name
      _ticker = source._ticker
      _price = source._price
      _quantity = source._quantity
      _orderAmount = source._orderAmount
      _aciValue = source._aciValue
      _totalOrderAmount = source._totalOrderAmount
      _brokerCommission = source._brokerCommission
      _exchangeCommission = source._exchangeCommission
      _exchangeClearingCommission = source._exchangeClearingCommission
      _repoRate = source._repoRate
      _party = source._party
      _clearValueDate_p = source._clearValueDate_p
      _secValueDate = source._secValueDate
      _brokerStatus = source._brokerStatus
      _separateAgreementType = source._separateAgreementType
      _separateAgreementNumber = source._separateAgreementNumber
      _separateAgreementDate = source._separateAgreementDate
      _deliveryType = source._deliveryType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._tradeID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._orderID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._figi) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._executeSign) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._tradeDatetime) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._exchange) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._classCode) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._direction) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._ticker) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._price) }()
        case 12: try { try decoder.decodeSingularInt64Field(value: &_storage._quantity) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._orderAmount) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._aciValue) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._totalOrderAmount) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._brokerCommission) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._exchangeCommission) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._exchangeClearingCommission) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._repoRate) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._party) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._clearValueDate_p) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._secValueDate) }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._brokerStatus) }()
        case 24: try { try decoder.decodeSingularStringField(value: &_storage._separateAgreementType) }()
        case 25: try { try decoder.decodeSingularStringField(value: &_storage._separateAgreementNumber) }()
        case 26: try { try decoder.decodeSingularStringField(value: &_storage._separateAgreementDate) }()
        case 27: try { try decoder.decodeSingularStringField(value: &_storage._deliveryType) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._tradeID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._tradeID, fieldNumber: 1)
      }
      if !_storage._orderID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._orderID, fieldNumber: 2)
      }
      if !_storage._figi.isEmpty {
        try visitor.visitSingularStringField(value: _storage._figi, fieldNumber: 3)
      }
      if !_storage._executeSign.isEmpty {
        try visitor.visitSingularStringField(value: _storage._executeSign, fieldNumber: 4)
      }
      try { if let v = _storage._tradeDatetime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._exchange.isEmpty {
        try visitor.visitSingularStringField(value: _storage._exchange, fieldNumber: 6)
      }
      if !_storage._classCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._classCode, fieldNumber: 7)
      }
      if !_storage._direction.isEmpty {
        try visitor.visitSingularStringField(value: _storage._direction, fieldNumber: 8)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 9)
      }
      if !_storage._ticker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ticker, fieldNumber: 10)
      }
      try { if let v = _storage._price {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if _storage._quantity != 0 {
        try visitor.visitSingularInt64Field(value: _storage._quantity, fieldNumber: 12)
      }
      try { if let v = _storage._orderAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._aciValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._totalOrderAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._brokerCommission {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._exchangeCommission {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._exchangeClearingCommission {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._repoRate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      if !_storage._party.isEmpty {
        try visitor.visitSingularStringField(value: _storage._party, fieldNumber: 20)
      }
      try { if let v = _storage._clearValueDate_p {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._secValueDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      if !_storage._brokerStatus.isEmpty {
        try visitor.visitSingularStringField(value: _storage._brokerStatus, fieldNumber: 23)
      }
      if !_storage._separateAgreementType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._separateAgreementType, fieldNumber: 24)
      }
      if !_storage._separateAgreementNumber.isEmpty {
        try visitor.visitSingularStringField(value: _storage._separateAgreementNumber, fieldNumber: 25)
      }
      if !_storage._separateAgreementDate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._separateAgreementDate, fieldNumber: 26)
      }
      if !_storage._deliveryType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._deliveryType, fieldNumber: 27)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BrokerReport, rhs: BrokerReport) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._tradeID != rhs_storage._tradeID {return false}
        if _storage._orderID != rhs_storage._orderID {return false}
        if _storage._figi != rhs_storage._figi {return false}
        if _storage._executeSign != rhs_storage._executeSign {return false}
        if _storage._tradeDatetime != rhs_storage._tradeDatetime {return false}
        if _storage._exchange != rhs_storage._exchange {return false}
        if _storage._classCode != rhs_storage._classCode {return false}
        if _storage._direction != rhs_storage._direction {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._ticker != rhs_storage._ticker {return false}
        if _storage._price != rhs_storage._price {return false}
        if _storage._quantity != rhs_storage._quantity {return false}
        if _storage._orderAmount != rhs_storage._orderAmount {return false}
        if _storage._aciValue != rhs_storage._aciValue {return false}
        if _storage._totalOrderAmount != rhs_storage._totalOrderAmount {return false}
        if _storage._brokerCommission != rhs_storage._brokerCommission {return false}
        if _storage._exchangeCommission != rhs_storage._exchangeCommission {return false}
        if _storage._exchangeClearingCommission != rhs_storage._exchangeClearingCommission {return false}
        if _storage._repoRate != rhs_storage._repoRate {return false}
        if _storage._party != rhs_storage._party {return false}
        if _storage._clearValueDate_p != rhs_storage._clearValueDate_p {return false}
        if _storage._secValueDate != rhs_storage._secValueDate {return false}
        if _storage._brokerStatus != rhs_storage._brokerStatus {return false}
        if _storage._separateAgreementType != rhs_storage._separateAgreementType {return false}
        if _storage._separateAgreementNumber != rhs_storage._separateAgreementNumber {return false}
        if _storage._separateAgreementDate != rhs_storage._separateAgreementDate {return false}
        if _storage._deliveryType != rhs_storage._deliveryType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetDividendsForeignIssuerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDividendsForeignIssuerRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "generate_div_foreign_issuer_report"),
    2: .standard(proto: "get_div_foreign_issuer_report"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: GenerateDividendsForeignIssuerReportRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .generateDivForeignIssuerReport(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .generateDivForeignIssuerReport(v)
        }
      }()
      case 2: try {
        var v: GetDividendsForeignIssuerReportRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .getDivForeignIssuerReport(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .getDivForeignIssuerReport(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .generateDivForeignIssuerReport?: try {
      guard case .generateDivForeignIssuerReport(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .getDivForeignIssuerReport?: try {
      guard case .getDivForeignIssuerReport(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetDividendsForeignIssuerRequest, rhs: GetDividendsForeignIssuerRequest) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetDividendsForeignIssuerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDividendsForeignIssuerResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "generate_div_foreign_issuer_report_response"),
    2: .standard(proto: "div_foreign_issuer_report"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: GenerateDividendsForeignIssuerReportResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .generateDivForeignIssuerReportResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .generateDivForeignIssuerReportResponse(v)
        }
      }()
      case 2: try {
        var v: GetDividendsForeignIssuerReportResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .divForeignIssuerReport(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .divForeignIssuerReport(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .generateDivForeignIssuerReportResponse?: try {
      guard case .generateDivForeignIssuerReportResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .divForeignIssuerReport?: try {
      guard case .divForeignIssuerReport(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetDividendsForeignIssuerResponse, rhs: GetDividendsForeignIssuerResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GenerateDividendsForeignIssuerReportRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateDividendsForeignIssuerReportRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GenerateDividendsForeignIssuerReportRequest, rhs: GenerateDividendsForeignIssuerReportRequest) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetDividendsForeignIssuerReportRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDividendsForeignIssuerReportRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "task_id"),
    2: .same(proto: "page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.taskID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.page) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 1)
    }
    if self.page != 0 {
      try visitor.visitSingularInt32Field(value: self.page, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetDividendsForeignIssuerReportRequest, rhs: GetDividendsForeignIssuerReportRequest) -> Bool {
    if lhs.taskID != rhs.taskID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GenerateDividendsForeignIssuerReportResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateDividendsForeignIssuerReportResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "task_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.taskID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GenerateDividendsForeignIssuerReportResponse, rhs: GenerateDividendsForeignIssuerReportResponse) -> Bool {
    if lhs.taskID != rhs.taskID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetDividendsForeignIssuerReportResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDividendsForeignIssuerReportResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dividends_foreign_issuer_report"),
    2: .same(proto: "itemsCount"),
    3: .same(proto: "pagesCount"),
    4: .same(proto: "page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.dividendsForeignIssuerReport) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.itemsCount) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pagesCount) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.page) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dividendsForeignIssuerReport.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dividendsForeignIssuerReport, fieldNumber: 1)
    }
    if self.itemsCount != 0 {
      try visitor.visitSingularInt32Field(value: self.itemsCount, fieldNumber: 2)
    }
    if self.pagesCount != 0 {
      try visitor.visitSingularInt32Field(value: self.pagesCount, fieldNumber: 3)
    }
    if self.page != 0 {
      try visitor.visitSingularInt32Field(value: self.page, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetDividendsForeignIssuerReportResponse, rhs: GetDividendsForeignIssuerReportResponse) -> Bool {
    if lhs.dividendsForeignIssuerReport != rhs.dividendsForeignIssuerReport {return false}
    if lhs.itemsCount != rhs.itemsCount {return false}
    if lhs.pagesCount != rhs.pagesCount {return false}
    if lhs.page != rhs.page {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DividendsForeignIssuerReport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DividendsForeignIssuerReport"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "record_date"),
    2: .standard(proto: "payment_date"),
    3: .standard(proto: "security_name"),
    4: .same(proto: "isin"),
    5: .standard(proto: "issuer_country"),
    6: .same(proto: "quantity"),
    7: .same(proto: "dividend"),
    8: .standard(proto: "external_commission"),
    9: .standard(proto: "dividend_gross"),
    10: .same(proto: "tax"),
    11: .standard(proto: "dividend_amount"),
    12: .same(proto: "currency"),
  ]

  fileprivate class _StorageClass {
    var _recordDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _paymentDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _securityName: String = String()
    var _isin: String = String()
    var _issuerCountry: String = String()
    var _quantity: Int64 = 0
    var _dividend: Quotation? = nil
    var _externalCommission: Quotation? = nil
    var _dividendGross: Quotation? = nil
    var _tax: Quotation? = nil
    var _dividendAmount: Quotation? = nil
    var _currency: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _recordDate = source._recordDate
      _paymentDate = source._paymentDate
      _securityName = source._securityName
      _isin = source._isin
      _issuerCountry = source._issuerCountry
      _quantity = source._quantity
      _dividend = source._dividend
      _externalCommission = source._externalCommission
      _dividendGross = source._dividendGross
      _tax = source._tax
      _dividendAmount = source._dividendAmount
      _currency = source._currency
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._recordDate) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._paymentDate) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._securityName) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._isin) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._issuerCountry) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._quantity) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._dividend) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._externalCommission) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._dividendGross) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._tax) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._dividendAmount) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._currency) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._recordDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._paymentDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._securityName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._securityName, fieldNumber: 3)
      }
      if !_storage._isin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._isin, fieldNumber: 4)
      }
      if !_storage._issuerCountry.isEmpty {
        try visitor.visitSingularStringField(value: _storage._issuerCountry, fieldNumber: 5)
      }
      if _storage._quantity != 0 {
        try visitor.visitSingularInt64Field(value: _storage._quantity, fieldNumber: 6)
      }
      try { if let v = _storage._dividend {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._externalCommission {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._dividendGross {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._tax {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._dividendAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if !_storage._currency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currency, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DividendsForeignIssuerReport, rhs: DividendsForeignIssuerReport) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._recordDate != rhs_storage._recordDate {return false}
        if _storage._paymentDate != rhs_storage._paymentDate {return false}
        if _storage._securityName != rhs_storage._securityName {return false}
        if _storage._isin != rhs_storage._isin {return false}
        if _storage._issuerCountry != rhs_storage._issuerCountry {return false}
        if _storage._quantity != rhs_storage._quantity {return false}
        if _storage._dividend != rhs_storage._dividend {return false}
        if _storage._externalCommission != rhs_storage._externalCommission {return false}
        if _storage._dividendGross != rhs_storage._dividendGross {return false}
        if _storage._tax != rhs_storage._tax {return false}
        if _storage._dividendAmount != rhs_storage._dividendAmount {return false}
        if _storage._currency != rhs_storage._currency {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PortfolioStreamRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PortfolioStreamRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accounts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.accounts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accounts.isEmpty {
      try visitor.visitRepeatedStringField(value: self.accounts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PortfolioStreamRequest, rhs: PortfolioStreamRequest) -> Bool {
    if lhs.accounts != rhs.accounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PortfolioStreamResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PortfolioStreamResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscriptions"),
    2: .same(proto: "portfolio"),
    3: .same(proto: "ping"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: PortfolioSubscriptionResult?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscriptions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscriptions(v)
        }
      }()
      case 2: try {
        var v: PortfolioResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .portfolio(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .portfolio(v)
        }
      }()
      case 3: try {
        var v: Ping?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .ping(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .subscriptions?: try {
      guard case .subscriptions(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .portfolio?: try {
      guard case .portfolio(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .ping?: try {
      guard case .ping(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PortfolioStreamResponse, rhs: PortfolioStreamResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PortfolioSubscriptionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PortfolioSubscriptionResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accounts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.accounts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accounts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accounts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PortfolioSubscriptionResult, rhs: PortfolioSubscriptionResult) -> Bool {
    if lhs.accounts != rhs.accounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AccountSubscriptionStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountSubscriptionStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    6: .standard(proto: "subscription_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.subscriptionStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    if self.subscriptionStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionStatus, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AccountSubscriptionStatus, rhs: AccountSubscriptionStatus) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs.subscriptionStatus != rhs.subscriptionStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetOperationsByCursorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetOperationsByCursorRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .standard(proto: "instrument_id"),
    6: .same(proto: "from"),
    7: .same(proto: "to"),
    11: .same(proto: "cursor"),
    12: .same(proto: "limit"),
    13: .standard(proto: "operation_types"),
    14: .same(proto: "state"),
    15: .standard(proto: "without_commissions"),
    16: .standard(proto: "without_trades"),
    17: .standard(proto: "without_overnights"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      case 13: try { try decoder.decodeRepeatedEnumField(value: &self.operationTypes) }()
      case 14: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 15: try { try decoder.decodeSingularBoolField(value: &self.withoutCommissions) }()
      case 16: try { try decoder.decodeSingularBoolField(value: &self.withoutTrades) }()
      case 17: try { try decoder.decodeSingularBoolField(value: &self.withoutOvernights) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 2)
    }
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 11)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 12)
    }
    if !self.operationTypes.isEmpty {
      try visitor.visitPackedEnumField(value: self.operationTypes, fieldNumber: 13)
    }
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 14)
    }
    if self.withoutCommissions != false {
      try visitor.visitSingularBoolField(value: self.withoutCommissions, fieldNumber: 15)
    }
    if self.withoutTrades != false {
      try visitor.visitSingularBoolField(value: self.withoutTrades, fieldNumber: 16)
    }
    if self.withoutOvernights != false {
      try visitor.visitSingularBoolField(value: self.withoutOvernights, fieldNumber: 17)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetOperationsByCursorRequest, rhs: GetOperationsByCursorRequest) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.operationTypes != rhs.operationTypes {return false}
    if lhs.state != rhs.state {return false}
    if lhs.withoutCommissions != rhs.withoutCommissions {return false}
    if lhs.withoutTrades != rhs.withoutTrades {return false}
    if lhs.withoutOvernights != rhs.withoutOvernights {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetOperationsByCursorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetOperationsByCursorResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "has_next"),
    2: .standard(proto: "next_cursor"),
    6: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.hasNext_p) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextCursor) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hasNext_p != false {
      try visitor.visitSingularBoolField(value: self.hasNext_p, fieldNumber: 1)
    }
    if !self.nextCursor.isEmpty {
      try visitor.visitSingularStringField(value: self.nextCursor, fieldNumber: 2)
    }
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetOperationsByCursorResponse, rhs: GetOperationsByCursorResponse) -> Bool {
    if lhs.hasNext_p != rhs.hasNext_p {return false}
    if lhs.nextCursor != rhs.nextCursor {return false}
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OperationItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OperationItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cursor"),
    6: .standard(proto: "broker_account_id"),
    16: .same(proto: "id"),
    17: .standard(proto: "parent_operation_id"),
    18: .same(proto: "name"),
    21: .same(proto: "date"),
    22: .same(proto: "type"),
    23: .same(proto: "description"),
    24: .same(proto: "state"),
    31: .standard(proto: "instrument_uid"),
    32: .same(proto: "figi"),
    33: .standard(proto: "instrument_type"),
    34: .standard(proto: "instrument_kind"),
    41: .same(proto: "payment"),
    42: .same(proto: "price"),
    43: .same(proto: "commission"),
    44: .same(proto: "yield"),
    45: .standard(proto: "yield_relative"),
    46: .standard(proto: "accrued_int"),
    51: .same(proto: "quantity"),
    52: .standard(proto: "quantity_rest"),
    53: .standard(proto: "quantity_done"),
    56: .standard(proto: "cancel_date_time"),
    57: .standard(proto: "cancel_reason"),
    61: .standard(proto: "trades_info"),
  ]

  fileprivate class _StorageClass {
    var _cursor: String = String()
    var _brokerAccountID: String = String()
    var _id: String = String()
    var _parentOperationID: String = String()
    var _name: String = String()
    var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _type: OperationType = .unspecified
    var _description_p: String = String()
    var _state: OperationState = .unspecified
    var _instrumentUid: String = String()
    var _figi: String = String()
    var _instrumentType: String = String()
    var _instrumentKind: InstrumentType = .unspecified
    var _payment: MoneyValue? = nil
    var _price: MoneyValue? = nil
    var _commission: MoneyValue? = nil
    var _yield: MoneyValue? = nil
    var _yieldRelative: Quotation? = nil
    var _accruedInt: MoneyValue? = nil
    var _quantity: Int64 = 0
    var _quantityRest: Int64 = 0
    var _quantityDone: Int64 = 0
    var _cancelDateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _cancelReason: String = String()
    var _tradesInfo: OperationItemTrades? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _cursor = source._cursor
      _brokerAccountID = source._brokerAccountID
      _id = source._id
      _parentOperationID = source._parentOperationID
      _name = source._name
      _date = source._date
      _type = source._type
      _description_p = source._description_p
      _state = source._state
      _instrumentUid = source._instrumentUid
      _figi = source._figi
      _instrumentType = source._instrumentType
      _instrumentKind = source._instrumentKind
      _payment = source._payment
      _price = source._price
      _commission = source._commission
      _yield = source._yield
      _yieldRelative = source._yieldRelative
      _accruedInt = source._accruedInt
      _quantity = source._quantity
      _quantityRest = source._quantityRest
      _quantityDone = source._quantityDone
      _cancelDateTime = source._cancelDateTime
      _cancelReason = source._cancelReason
      _tradesInfo = source._tradesInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._cursor) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._brokerAccountID) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._parentOperationID) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._date) }()
        case 22: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 24: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 31: try { try decoder.decodeSingularStringField(value: &_storage._instrumentUid) }()
        case 32: try { try decoder.decodeSingularStringField(value: &_storage._figi) }()
        case 33: try { try decoder.decodeSingularStringField(value: &_storage._instrumentType) }()
        case 34: try { try decoder.decodeSingularEnumField(value: &_storage._instrumentKind) }()
        case 41: try { try decoder.decodeSingularMessageField(value: &_storage._payment) }()
        case 42: try { try decoder.decodeSingularMessageField(value: &_storage._price) }()
        case 43: try { try decoder.decodeSingularMessageField(value: &_storage._commission) }()
        case 44: try { try decoder.decodeSingularMessageField(value: &_storage._yield) }()
        case 45: try { try decoder.decodeSingularMessageField(value: &_storage._yieldRelative) }()
        case 46: try { try decoder.decodeSingularMessageField(value: &_storage._accruedInt) }()
        case 51: try { try decoder.decodeSingularInt64Field(value: &_storage._quantity) }()
        case 52: try { try decoder.decodeSingularInt64Field(value: &_storage._quantityRest) }()
        case 53: try { try decoder.decodeSingularInt64Field(value: &_storage._quantityDone) }()
        case 56: try { try decoder.decodeSingularMessageField(value: &_storage._cancelDateTime) }()
        case 57: try { try decoder.decodeSingularStringField(value: &_storage._cancelReason) }()
        case 61: try { try decoder.decodeSingularMessageField(value: &_storage._tradesInfo) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._cursor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cursor, fieldNumber: 1)
      }
      if !_storage._brokerAccountID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._brokerAccountID, fieldNumber: 6)
      }
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 16)
      }
      if !_storage._parentOperationID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._parentOperationID, fieldNumber: 17)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 18)
      }
      try { if let v = _storage._date {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      if _storage._type != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 22)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 23)
      }
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 24)
      }
      if !_storage._instrumentUid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._instrumentUid, fieldNumber: 31)
      }
      if !_storage._figi.isEmpty {
        try visitor.visitSingularStringField(value: _storage._figi, fieldNumber: 32)
      }
      if !_storage._instrumentType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._instrumentType, fieldNumber: 33)
      }
      if _storage._instrumentKind != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._instrumentKind, fieldNumber: 34)
      }
      try { if let v = _storage._payment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
      } }()
      try { if let v = _storage._price {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
      } }()
      try { if let v = _storage._commission {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
      } }()
      try { if let v = _storage._yield {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
      } }()
      try { if let v = _storage._yieldRelative {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
      } }()
      try { if let v = _storage._accruedInt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
      } }()
      if _storage._quantity != 0 {
        try visitor.visitSingularInt64Field(value: _storage._quantity, fieldNumber: 51)
      }
      if _storage._quantityRest != 0 {
        try visitor.visitSingularInt64Field(value: _storage._quantityRest, fieldNumber: 52)
      }
      if _storage._quantityDone != 0 {
        try visitor.visitSingularInt64Field(value: _storage._quantityDone, fieldNumber: 53)
      }
      try { if let v = _storage._cancelDateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 56)
      } }()
      if !_storage._cancelReason.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cancelReason, fieldNumber: 57)
      }
      try { if let v = _storage._tradesInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OperationItem, rhs: OperationItem) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._cursor != rhs_storage._cursor {return false}
        if _storage._brokerAccountID != rhs_storage._brokerAccountID {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._parentOperationID != rhs_storage._parentOperationID {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._date != rhs_storage._date {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._instrumentUid != rhs_storage._instrumentUid {return false}
        if _storage._figi != rhs_storage._figi {return false}
        if _storage._instrumentType != rhs_storage._instrumentType {return false}
        if _storage._instrumentKind != rhs_storage._instrumentKind {return false}
        if _storage._payment != rhs_storage._payment {return false}
        if _storage._price != rhs_storage._price {return false}
        if _storage._commission != rhs_storage._commission {return false}
        if _storage._yield != rhs_storage._yield {return false}
        if _storage._yieldRelative != rhs_storage._yieldRelative {return false}
        if _storage._accruedInt != rhs_storage._accruedInt {return false}
        if _storage._quantity != rhs_storage._quantity {return false}
        if _storage._quantityRest != rhs_storage._quantityRest {return false}
        if _storage._quantityDone != rhs_storage._quantityDone {return false}
        if _storage._cancelDateTime != rhs_storage._cancelDateTime {return false}
        if _storage._cancelReason != rhs_storage._cancelReason {return false}
        if _storage._tradesInfo != rhs_storage._tradesInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OperationItemTrades: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OperationItemTrades"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    6: .same(proto: "trades"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.trades) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trades.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.trades, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OperationItemTrades, rhs: OperationItemTrades) -> Bool {
    if lhs.trades != rhs.trades {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OperationItemTrade: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OperationItemTrade"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "num"),
    6: .same(proto: "date"),
    11: .same(proto: "quantity"),
    16: .same(proto: "price"),
    21: .same(proto: "yield"),
    22: .standard(proto: "yield_relative"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.num) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.quantity) }()
      case 16: try { try decoder.decodeSingularMessageField(value: &self._price) }()
      case 21: try { try decoder.decodeSingularMessageField(value: &self._yield) }()
      case 22: try { try decoder.decodeSingularMessageField(value: &self._yieldRelative) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.num.isEmpty {
      try visitor.visitSingularStringField(value: self.num, fieldNumber: 1)
    }
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.quantity != 0 {
      try visitor.visitSingularInt64Field(value: self.quantity, fieldNumber: 11)
    }
    try { if let v = self._price {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    } }()
    try { if let v = self._yield {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    } }()
    try { if let v = self._yieldRelative {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OperationItemTrade, rhs: OperationItemTrade) -> Bool {
    if lhs.num != rhs.num {return false}
    if lhs._date != rhs._date {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs._price != rhs._price {return false}
    if lhs._yield != rhs._yield {return false}
    if lhs._yieldRelative != rhs._yieldRelative {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PositionsStreamRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PositionsStreamRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accounts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.accounts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accounts.isEmpty {
      try visitor.visitRepeatedStringField(value: self.accounts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PositionsStreamRequest, rhs: PositionsStreamRequest) -> Bool {
    if lhs.accounts != rhs.accounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PositionsStreamResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PositionsStreamResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscriptions"),
    2: .same(proto: "position"),
    3: .same(proto: "ping"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: PositionsSubscriptionResult?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscriptions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscriptions(v)
        }
      }()
      case 2: try {
        var v: PositionData?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .position(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .position(v)
        }
      }()
      case 3: try {
        var v: Ping?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .ping(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .subscriptions?: try {
      guard case .subscriptions(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .position?: try {
      guard case .position(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .ping?: try {
      guard case .ping(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PositionsStreamResponse, rhs: PositionsStreamResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PositionsSubscriptionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PositionsSubscriptionResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accounts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.accounts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accounts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accounts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PositionsSubscriptionResult, rhs: PositionsSubscriptionResult) -> Bool {
    if lhs.accounts != rhs.accounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PositionsSubscriptionStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PositionsSubscriptionStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    6: .standard(proto: "subscription_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.subscriptionStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    if self.subscriptionStatus != .positionsSubscriptionStatusUnspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionStatus, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PositionsSubscriptionStatus, rhs: PositionsSubscriptionStatus) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs.subscriptionStatus != rhs.subscriptionStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PositionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PositionData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .same(proto: "money"),
    3: .same(proto: "securities"),
    4: .same(proto: "futures"),
    5: .same(proto: "options"),
    6: .same(proto: "date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.money) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.securities) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.futures) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.options) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    if !self.money.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.money, fieldNumber: 2)
    }
    if !self.securities.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.securities, fieldNumber: 3)
    }
    if !self.futures.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.futures, fieldNumber: 4)
    }
    if !self.options.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.options, fieldNumber: 5)
    }
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PositionData, rhs: PositionData) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs.money != rhs.money {return false}
    if lhs.securities != rhs.securities {return false}
    if lhs.futures != rhs.futures {return false}
    if lhs.options != rhs.options {return false}
    if lhs._date != rhs._date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PositionsMoney: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PositionsMoney"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "available_value"),
    2: .standard(proto: "blocked_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._availableValue) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._blockedValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._availableValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._blockedValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PositionsMoney, rhs: PositionsMoney) -> Bool {
    if lhs._availableValue != rhs._availableValue {return false}
    if lhs._blockedValue != rhs._blockedValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
