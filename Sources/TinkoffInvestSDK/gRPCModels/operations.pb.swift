// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: operations.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///Статус запрашиваемых операций
public enum OperationState: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Статус операции не определён
  case unspecified // = 0

  ///Исполнена
  case executed // = 1

  ///Отменена
  case canceled // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .executed
    case 2: self = .canceled
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .executed: return 1
    case .canceled: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension OperationState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [OperationState] = [
    .unspecified,
    .executed,
    .canceled,
  ]
}

#endif  // swift(>=4.2)

///Тип операции
public enum OperationType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Тип операции не определён
  case unspecified // = 0

  ///Завод денежных средств
  case input // = 1

  ///Удержание налога по купонам
  case bondTax // = 2

  ///Вывод ЦБ
  case outputSecurities // = 3

  ///Доход по сделке РЕПО овернайт
  case overnight // = 4

  ///Удержание налога
  case tax // = 5

  ///Полное погашение облигаций
  case bondRepaymentFull // = 6

  ///Продажа ЦБ с карты
  case sellCard // = 7

  ///Удержание налога по дивидендам
  case dividendTax // = 8

  ///Вывод денежных средств
  case output // = 9

  ///Частичное погашение облигаций
  case bondRepayment // = 10

  ///Корректировка налога
  case taxCorrection // = 11

  ///Удержание комиссии за обслуживание брокерского счёта
  case serviceFee // = 12

  ///Удержание налога за материальную выгоду
  case benefitTax // = 13

  ///Удержание комиссии за непокрытую позицию
  case marginFee // = 14

  ///Покупка ЦБ
  case buy // = 15

  ///Покупка ЦБ с карты
  case buyCard // = 16

  ///Завод ЦБ
  case inputSecurities // = 17

  ///Продажа в результате Margin-call
  case sellMargin // = 18

  ///Удержание комиссии за операцию
  case brokerFee // = 19

  ///Покупка в результате Margin-call
  case buyMargin // = 20

  ///Выплата дивидендов
  case dividend // = 21

  ///Продажа ЦБ
  case sell // = 22

  ///Выплата купонов
  case coupon // = 23

  ///Удержание комиссии SuccessFee
  case successFee // = 24

  ///Передача дивидендного дохода
  case dividendTransfer // = 25

  ///Зачисление вариационной маржи
  case accruingVarmargin // = 26

  ///Списание вариационной маржи
  case writingOffVarmargin // = 27

  ///Покупка в рамках экспирации фьючерсного контракта
  case deliveryBuy // = 28

  ///Продажа в рамках экспирации фьючерсного контракта
  case deliverySell // = 29

  ///Комиссия за управление по счёту автоследования
  case trackMfee // = 30

  ///Комиссия за результат по счёту автоследования
  case trackPfee // = 31

  ///Удержание налога по ставке 15%
  case taxProgressive // = 32

  ///Удержание налога по купонам по ставке 15%
  case bondTaxProgressive // = 33

  ///Удержание налога по дивидендам по ставке 15%
  case dividendTaxProgressive // = 34

  ///Удержание налога за материальную выгоду по ставке 15%
  case benefitTaxProgressive // = 35

  ///Корректировка налога по ставке 15%
  case taxCorrectionProgressive // = 36

  ///Удержание налога за возмещение по сделкам РЕПО по ставке 15%
  case taxRepoProgressive // = 37

  ///Удержание налога за возмещение по сделкам РЕПО
  case taxRepo // = 38

  ///Удержание налога по сделкам РЕПО
  case taxRepoHold // = 39

  ///Возврат налога по сделкам РЕПО
  case taxRepoRefund // = 40

  ///Удержание налога по сделкам РЕПО по ставке 15%
  case taxRepoHoldProgressive // = 41

  ///Возврат налога по сделкам РЕПО по ставке 15%
  case taxRepoRefundProgressive // = 42

  ///Выплата дивидендов на карту
  case divExt // = 43
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .input
    case 2: self = .bondTax
    case 3: self = .outputSecurities
    case 4: self = .overnight
    case 5: self = .tax
    case 6: self = .bondRepaymentFull
    case 7: self = .sellCard
    case 8: self = .dividendTax
    case 9: self = .output
    case 10: self = .bondRepayment
    case 11: self = .taxCorrection
    case 12: self = .serviceFee
    case 13: self = .benefitTax
    case 14: self = .marginFee
    case 15: self = .buy
    case 16: self = .buyCard
    case 17: self = .inputSecurities
    case 18: self = .sellMargin
    case 19: self = .brokerFee
    case 20: self = .buyMargin
    case 21: self = .dividend
    case 22: self = .sell
    case 23: self = .coupon
    case 24: self = .successFee
    case 25: self = .dividendTransfer
    case 26: self = .accruingVarmargin
    case 27: self = .writingOffVarmargin
    case 28: self = .deliveryBuy
    case 29: self = .deliverySell
    case 30: self = .trackMfee
    case 31: self = .trackPfee
    case 32: self = .taxProgressive
    case 33: self = .bondTaxProgressive
    case 34: self = .dividendTaxProgressive
    case 35: self = .benefitTaxProgressive
    case 36: self = .taxCorrectionProgressive
    case 37: self = .taxRepoProgressive
    case 38: self = .taxRepo
    case 39: self = .taxRepoHold
    case 40: self = .taxRepoRefund
    case 41: self = .taxRepoHoldProgressive
    case 42: self = .taxRepoRefundProgressive
    case 43: self = .divExt
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .input: return 1
    case .bondTax: return 2
    case .outputSecurities: return 3
    case .overnight: return 4
    case .tax: return 5
    case .bondRepaymentFull: return 6
    case .sellCard: return 7
    case .dividendTax: return 8
    case .output: return 9
    case .bondRepayment: return 10
    case .taxCorrection: return 11
    case .serviceFee: return 12
    case .benefitTax: return 13
    case .marginFee: return 14
    case .buy: return 15
    case .buyCard: return 16
    case .inputSecurities: return 17
    case .sellMargin: return 18
    case .brokerFee: return 19
    case .buyMargin: return 20
    case .dividend: return 21
    case .sell: return 22
    case .coupon: return 23
    case .successFee: return 24
    case .dividendTransfer: return 25
    case .accruingVarmargin: return 26
    case .writingOffVarmargin: return 27
    case .deliveryBuy: return 28
    case .deliverySell: return 29
    case .trackMfee: return 30
    case .trackPfee: return 31
    case .taxProgressive: return 32
    case .bondTaxProgressive: return 33
    case .dividendTaxProgressive: return 34
    case .benefitTaxProgressive: return 35
    case .taxCorrectionProgressive: return 36
    case .taxRepoProgressive: return 37
    case .taxRepo: return 38
    case .taxRepoHold: return 39
    case .taxRepoRefund: return 40
    case .taxRepoHoldProgressive: return 41
    case .taxRepoRefundProgressive: return 42
    case .divExt: return 43
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension OperationType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [OperationType] = [
    .unspecified,
    .input,
    .bondTax,
    .outputSecurities,
    .overnight,
    .tax,
    .bondRepaymentFull,
    .sellCard,
    .dividendTax,
    .output,
    .bondRepayment,
    .taxCorrection,
    .serviceFee,
    .benefitTax,
    .marginFee,
    .buy,
    .buyCard,
    .inputSecurities,
    .sellMargin,
    .brokerFee,
    .buyMargin,
    .dividend,
    .sell,
    .coupon,
    .successFee,
    .dividendTransfer,
    .accruingVarmargin,
    .writingOffVarmargin,
    .deliveryBuy,
    .deliverySell,
    .trackMfee,
    .trackPfee,
    .taxProgressive,
    .bondTaxProgressive,
    .dividendTaxProgressive,
    .benefitTaxProgressive,
    .taxCorrectionProgressive,
    .taxRepoProgressive,
    .taxRepo,
    .taxRepoHold,
    .taxRepoRefund,
    .taxRepoHoldProgressive,
    .taxRepoRefundProgressive,
    .divExt,
  ]
}

#endif  // swift(>=4.2)

///Запрос получения списка операций по счёту.
public struct OperationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор счёта клиента
  public var accountID: String = String()

  ///Начало периода (по UTC)
  public var from: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  public var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  public mutating func clearFrom() {self._from = nil}

  ///Окончание периода (по UTC)
  public var to: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  public var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  public mutating func clearTo() {self._to = nil}

  ///Статус запрашиваемых операций
  public var state: OperationState = .unspecified

  ///Figi-идентификатор инструмента для фильтрации
  public var figi: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Список операций.
public struct OperationsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив операций
  public var operations: [Operation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Данные по операции.
public struct Operation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор операции
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  ///Идентификатор родительской операции
  public var parentOperationID: String {
    get {return _storage._parentOperationID}
    set {_uniqueStorage()._parentOperationID = newValue}
  }

  ///Валюта операции
  public var currency: String {
    get {return _storage._currency}
    set {_uniqueStorage()._currency = newValue}
  }

  ///Сумма операции
  public var payment: MoneyValue {
    get {return _storage._payment ?? MoneyValue()}
    set {_uniqueStorage()._payment = newValue}
  }
  /// Returns true if `payment` has been explicitly set.
  public var hasPayment: Bool {return _storage._payment != nil}
  /// Clears the value of `payment`. Subsequent reads from it will return its default value.
  public mutating func clearPayment() {_uniqueStorage()._payment = nil}

  ///Цена операции
  public var price: MoneyValue {
    get {return _storage._price ?? MoneyValue()}
    set {_uniqueStorage()._price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  public var hasPrice: Bool {return _storage._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  public mutating func clearPrice() {_uniqueStorage()._price = nil}

  ///Статус операции
  public var state: OperationState {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  ///Количество лотов инструмента
  public var quantity: Int64 {
    get {return _storage._quantity}
    set {_uniqueStorage()._quantity = newValue}
  }

  ///Неисполненный остаток по сделке
  public var quantityRest: Int64 {
    get {return _storage._quantityRest}
    set {_uniqueStorage()._quantityRest = newValue}
  }

  ///Figi-идентификатор инструмента, связанного с операцией
  public var figi: String {
    get {return _storage._figi}
    set {_uniqueStorage()._figi = newValue}
  }

  ///Тип инструмента. Возможные значения: </br>**bond** — облигация; </br>**share** — акция; </br>**currency** — валюта; </br>**etf** — фонд; </br>**futures** — фьючерс.
  public var instrumentType: String {
    get {return _storage._instrumentType}
    set {_uniqueStorage()._instrumentType = newValue}
  }

  ///Дата и время операции в формате часовом поясе UTC
  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return _storage._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {_uniqueStorage()._date = nil}

  ///Текстовое описание типа операции
  public var type: String {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  ///Тип операции
  public var operationType: OperationType {
    get {return _storage._operationType}
    set {_uniqueStorage()._operationType = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Запрос получения текущего портфеля по счёту.
public struct PortfolioRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор счёта пользователя
  public var accountID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Текущий портфель по счёту.
public struct PortfolioResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Общая стоимость акций в портфеле в рублях
  public var totalAmountShares: MoneyValue {
    get {return _storage._totalAmountShares ?? MoneyValue()}
    set {_uniqueStorage()._totalAmountShares = newValue}
  }
  /// Returns true if `totalAmountShares` has been explicitly set.
  public var hasTotalAmountShares: Bool {return _storage._totalAmountShares != nil}
  /// Clears the value of `totalAmountShares`. Subsequent reads from it will return its default value.
  public mutating func clearTotalAmountShares() {_uniqueStorage()._totalAmountShares = nil}

  ///Общая стоимость облигаций в портфеле в рублях
  public var totalAmountBonds: MoneyValue {
    get {return _storage._totalAmountBonds ?? MoneyValue()}
    set {_uniqueStorage()._totalAmountBonds = newValue}
  }
  /// Returns true if `totalAmountBonds` has been explicitly set.
  public var hasTotalAmountBonds: Bool {return _storage._totalAmountBonds != nil}
  /// Clears the value of `totalAmountBonds`. Subsequent reads from it will return its default value.
  public mutating func clearTotalAmountBonds() {_uniqueStorage()._totalAmountBonds = nil}

  ///Общая стоимость фондов в портфеле в рублях
  public var totalAmountEtf: MoneyValue {
    get {return _storage._totalAmountEtf ?? MoneyValue()}
    set {_uniqueStorage()._totalAmountEtf = newValue}
  }
  /// Returns true if `totalAmountEtf` has been explicitly set.
  public var hasTotalAmountEtf: Bool {return _storage._totalAmountEtf != nil}
  /// Clears the value of `totalAmountEtf`. Subsequent reads from it will return its default value.
  public mutating func clearTotalAmountEtf() {_uniqueStorage()._totalAmountEtf = nil}

  ///Общая стоимость валют в портфеле в рублях
  public var totalAmountCurrencies: MoneyValue {
    get {return _storage._totalAmountCurrencies ?? MoneyValue()}
    set {_uniqueStorage()._totalAmountCurrencies = newValue}
  }
  /// Returns true if `totalAmountCurrencies` has been explicitly set.
  public var hasTotalAmountCurrencies: Bool {return _storage._totalAmountCurrencies != nil}
  /// Clears the value of `totalAmountCurrencies`. Subsequent reads from it will return its default value.
  public mutating func clearTotalAmountCurrencies() {_uniqueStorage()._totalAmountCurrencies = nil}

  ///Общая стоимость фьючерсов в портфеле в рублях
  public var totalAmountFutures: MoneyValue {
    get {return _storage._totalAmountFutures ?? MoneyValue()}
    set {_uniqueStorage()._totalAmountFutures = newValue}
  }
  /// Returns true if `totalAmountFutures` has been explicitly set.
  public var hasTotalAmountFutures: Bool {return _storage._totalAmountFutures != nil}
  /// Clears the value of `totalAmountFutures`. Subsequent reads from it will return its default value.
  public mutating func clearTotalAmountFutures() {_uniqueStorage()._totalAmountFutures = nil}

  ///Текущая доходность портфеля
  public var expectedYield: Quotation {
    get {return _storage._expectedYield ?? Quotation()}
    set {_uniqueStorage()._expectedYield = newValue}
  }
  /// Returns true if `expectedYield` has been explicitly set.
  public var hasExpectedYield: Bool {return _storage._expectedYield != nil}
  /// Clears the value of `expectedYield`. Subsequent reads from it will return its default value.
  public mutating func clearExpectedYield() {_uniqueStorage()._expectedYield = nil}

  ///Список позиций портфеля
  public var positions: [PortfolioPosition] {
    get {return _storage._positions}
    set {_uniqueStorage()._positions = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Запрос позиций портфеля по счёту.
public struct PositionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор счёта пользователя
  public var accountID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Список позиций по счёту.
public struct PositionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив валютных позиций портфеля
  public var money: [MoneyValue] = []

  ///Массив заблокированных валютных позиций портфеля
  public var blocked: [MoneyValue] = []

  ///Список ценно-бумажных позиций портфеля
  public var securities: [PositionsSecurities] = []

  ///Признак идущей в данный момент выгрузки лимитов
  public var limitsLoadingInProgress: Bool = false

  ///Список фьючерсов портфеля
  public var futures: [PositionsFutures] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос доступного для вывода остатка.
public struct WithdrawLimitsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор счёта пользователя
  public var accountID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Доступный для вывода остаток.
public struct WithdrawLimitsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив валютных позиций портфеля
  public var money: [MoneyValue] = []

  ///Массив заблокированных валютных позиций портфеля
  public var blocked: [MoneyValue] = []

  ///Заблокировано под гарантийное обеспечение фьючерсов
  public var blockedGuarantee: [MoneyValue] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Позиции портфеля.
public struct PortfolioPosition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатора инструмента
  public var figi: String {
    get {return _storage._figi}
    set {_uniqueStorage()._figi = newValue}
  }

  ///Тип инструмента
  public var instrumentType: String {
    get {return _storage._instrumentType}
    set {_uniqueStorage()._instrumentType = newValue}
  }

  ///Количество инструмента в портфеле в штуках
  public var quantity: Quotation {
    get {return _storage._quantity ?? Quotation()}
    set {_uniqueStorage()._quantity = newValue}
  }
  /// Returns true if `quantity` has been explicitly set.
  public var hasQuantity: Bool {return _storage._quantity != nil}
  /// Clears the value of `quantity`. Subsequent reads from it will return its default value.
  public mutating func clearQuantity() {_uniqueStorage()._quantity = nil}

  ///Средняя цена лота в позиции
  public var averagePositionPrice: MoneyValue {
    get {return _storage._averagePositionPrice ?? MoneyValue()}
    set {_uniqueStorage()._averagePositionPrice = newValue}
  }
  /// Returns true if `averagePositionPrice` has been explicitly set.
  public var hasAveragePositionPrice: Bool {return _storage._averagePositionPrice != nil}
  /// Clears the value of `averagePositionPrice`. Subsequent reads from it will return its default value.
  public mutating func clearAveragePositionPrice() {_uniqueStorage()._averagePositionPrice = nil}

  ///Текущая рассчитанная доходность
  public var expectedYield: Quotation {
    get {return _storage._expectedYield ?? Quotation()}
    set {_uniqueStorage()._expectedYield = newValue}
  }
  /// Returns true if `expectedYield` has been explicitly set.
  public var hasExpectedYield: Bool {return _storage._expectedYield != nil}
  /// Clears the value of `expectedYield`. Subsequent reads from it will return its default value.
  public mutating func clearExpectedYield() {_uniqueStorage()._expectedYield = nil}

  /// Текущий НКД
  public var currentNkd: MoneyValue {
    get {return _storage._currentNkd ?? MoneyValue()}
    set {_uniqueStorage()._currentNkd = newValue}
  }
  /// Returns true if `currentNkd` has been explicitly set.
  public var hasCurrentNkd: Bool {return _storage._currentNkd != nil}
  /// Clears the value of `currentNkd`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentNkd() {_uniqueStorage()._currentNkd = nil}

  ///Средняя цена лота в позиции в пунктах (для фьючерсов)
  public var averagePositionPricePt: Quotation {
    get {return _storage._averagePositionPricePt ?? Quotation()}
    set {_uniqueStorage()._averagePositionPricePt = newValue}
  }
  /// Returns true if `averagePositionPricePt` has been explicitly set.
  public var hasAveragePositionPricePt: Bool {return _storage._averagePositionPricePt != nil}
  /// Clears the value of `averagePositionPricePt`. Subsequent reads from it will return its default value.
  public mutating func clearAveragePositionPricePt() {_uniqueStorage()._averagePositionPricePt = nil}

  ///Текущая цена инструмента
  public var currentPrice: MoneyValue {
    get {return _storage._currentPrice ?? MoneyValue()}
    set {_uniqueStorage()._currentPrice = newValue}
  }
    
  ///Средняя цена позиции по методу FIFO. Возможна задержка до секунды для пересчёта.
  public var averagePositionPriceFifo: MoneyValue {
    get {return _storage._averagePositionPriceFifo ?? MoneyValue()}
    set {_uniqueStorage()._averagePositionPriceFifo = newValue}
  }

  ///Количество лотов в портфеле.
  public var quantityLots: Quotation {
    get {return _storage._quantityLots ?? Quotation()}
    set {_uniqueStorage()._quantityLots = newValue}
  }
    
  ///Заблокировано
  public var blocked: Bool {
    get {return _storage._blocked ?? false}
    set {_uniqueStorage()._blocked = newValue}
  }
  
  /// Returns true if `currentPrice` has been explicitly set.
  public var hasCurrentPrice: Bool {return _storage._currentPrice != nil}
  /// Clears the value of `currentPrice`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentPrice() {_uniqueStorage()._currentPrice = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Баланс позиции ценной бумаги.
public struct PositionsSecurities {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор бумаги
  public var figi: String = String()

  ///Заблокировано
  public var blocked: Int64 = 0

  ///Текущий баланс
  public var balance: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Баланс фьючерса.
public struct PositionsFutures {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор фьючерса
  public var figi: String = String()

  ///Заблокировано
  public var blocked: Int64 = 0

  ///Текущий баланс
  public var balance: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tinkoff.public.invest.api.contract.v1"

extension OperationState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPERATION_STATE_UNSPECIFIED"),
    1: .same(proto: "OPERATION_STATE_EXECUTED"),
    2: .same(proto: "OPERATION_STATE_CANCELED"),
  ]
}

extension OperationType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPERATION_TYPE_UNSPECIFIED"),
    1: .same(proto: "OPERATION_TYPE_INPUT"),
    2: .same(proto: "OPERATION_TYPE_BOND_TAX"),
    3: .same(proto: "OPERATION_TYPE_OUTPUT_SECURITIES"),
    4: .same(proto: "OPERATION_TYPE_OVERNIGHT"),
    5: .same(proto: "OPERATION_TYPE_TAX"),
    6: .same(proto: "OPERATION_TYPE_BOND_REPAYMENT_FULL"),
    7: .same(proto: "OPERATION_TYPE_SELL_CARD"),
    8: .same(proto: "OPERATION_TYPE_DIVIDEND_TAX"),
    9: .same(proto: "OPERATION_TYPE_OUTPUT"),
    10: .same(proto: "OPERATION_TYPE_BOND_REPAYMENT"),
    11: .same(proto: "OPERATION_TYPE_TAX_CORRECTION"),
    12: .same(proto: "OPERATION_TYPE_SERVICE_FEE"),
    13: .same(proto: "OPERATION_TYPE_BENEFIT_TAX"),
    14: .same(proto: "OPERATION_TYPE_MARGIN_FEE"),
    15: .same(proto: "OPERATION_TYPE_BUY"),
    16: .same(proto: "OPERATION_TYPE_BUY_CARD"),
    17: .same(proto: "OPERATION_TYPE_INPUT_SECURITIES"),
    18: .same(proto: "OPERATION_TYPE_SELL_MARGIN"),
    19: .same(proto: "OPERATION_TYPE_BROKER_FEE"),
    20: .same(proto: "OPERATION_TYPE_BUY_MARGIN"),
    21: .same(proto: "OPERATION_TYPE_DIVIDEND"),
    22: .same(proto: "OPERATION_TYPE_SELL"),
    23: .same(proto: "OPERATION_TYPE_COUPON"),
    24: .same(proto: "OPERATION_TYPE_SUCCESS_FEE"),
    25: .same(proto: "OPERATION_TYPE_DIVIDEND_TRANSFER"),
    26: .same(proto: "OPERATION_TYPE_ACCRUING_VARMARGIN"),
    27: .same(proto: "OPERATION_TYPE_WRITING_OFF_VARMARGIN"),
    28: .same(proto: "OPERATION_TYPE_DELIVERY_BUY"),
    29: .same(proto: "OPERATION_TYPE_DELIVERY_SELL"),
    30: .same(proto: "OPERATION_TYPE_TRACK_MFEE"),
    31: .same(proto: "OPERATION_TYPE_TRACK_PFEE"),
    32: .same(proto: "OPERATION_TYPE_TAX_PROGRESSIVE"),
    33: .same(proto: "OPERATION_TYPE_BOND_TAX_PROGRESSIVE"),
    34: .same(proto: "OPERATION_TYPE_DIVIDEND_TAX_PROGRESSIVE"),
    35: .same(proto: "OPERATION_TYPE_BENEFIT_TAX_PROGRESSIVE"),
    36: .same(proto: "OPERATION_TYPE_TAX_CORRECTION_PROGRESSIVE"),
    37: .same(proto: "OPERATION_TYPE_TAX_REPO_PROGRESSIVE"),
    38: .same(proto: "OPERATION_TYPE_TAX_REPO"),
    39: .same(proto: "OPERATION_TYPE_TAX_REPO_HOLD"),
    40: .same(proto: "OPERATION_TYPE_TAX_REPO_REFUND"),
    41: .same(proto: "OPERATION_TYPE_TAX_REPO_HOLD_PROGRESSIVE"),
    42: .same(proto: "OPERATION_TYPE_TAX_REPO_REFUND_PROGRESSIVE"),
    43: .same(proto: "OPERATION_TYPE_DIV_EXT"),
  ]
}

extension OperationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OperationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
    4: .same(proto: "state"),
    5: .same(proto: "figi"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 4)
    }
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OperationsRequest, rhs: OperationsRequest) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs.state != rhs.state {return false}
    if lhs.figi != rhs.figi {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OperationsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OperationsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.operations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.operations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.operations, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OperationsResponse, rhs: OperationsResponse) -> Bool {
    if lhs.operations != rhs.operations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Operation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Operation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "parent_operation_id"),
    3: .same(proto: "currency"),
    4: .same(proto: "payment"),
    5: .same(proto: "price"),
    6: .same(proto: "state"),
    7: .same(proto: "quantity"),
    8: .standard(proto: "quantity_rest"),
    9: .same(proto: "figi"),
    10: .standard(proto: "instrument_type"),
    11: .same(proto: "date"),
    12: .same(proto: "type"),
    13: .standard(proto: "operation_type"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _parentOperationID: String = String()
    var _currency: String = String()
    var _payment: MoneyValue? = nil
    var _price: MoneyValue? = nil
    var _state: OperationState = .unspecified
    var _quantity: Int64 = 0
    var _quantityRest: Int64 = 0
    var _figi: String = String()
    var _instrumentType: String = String()
    var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _type: String = String()
    var _operationType: OperationType = .unspecified

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _parentOperationID = source._parentOperationID
      _currency = source._currency
      _payment = source._payment
      _price = source._price
      _state = source._state
      _quantity = source._quantity
      _quantityRest = source._quantityRest
      _figi = source._figi
      _instrumentType = source._instrumentType
      _date = source._date
      _type = source._type
      _operationType = source._operationType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._parentOperationID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._currency) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._payment) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._price) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 7: try { try decoder.decodeSingularInt64Field(value: &_storage._quantity) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._quantityRest) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._figi) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._instrumentType) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._date) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._type) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._operationType) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._parentOperationID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._parentOperationID, fieldNumber: 2)
      }
      if !_storage._currency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currency, fieldNumber: 3)
      }
      try { if let v = _storage._payment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._price {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 6)
      }
      if _storage._quantity != 0 {
        try visitor.visitSingularInt64Field(value: _storage._quantity, fieldNumber: 7)
      }
      if _storage._quantityRest != 0 {
        try visitor.visitSingularInt64Field(value: _storage._quantityRest, fieldNumber: 8)
      }
      if !_storage._figi.isEmpty {
        try visitor.visitSingularStringField(value: _storage._figi, fieldNumber: 9)
      }
      if !_storage._instrumentType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._instrumentType, fieldNumber: 10)
      }
      try { if let v = _storage._date {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if !_storage._type.isEmpty {
        try visitor.visitSingularStringField(value: _storage._type, fieldNumber: 12)
      }
      if _storage._operationType != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._operationType, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Operation, rhs: Operation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._parentOperationID != rhs_storage._parentOperationID {return false}
        if _storage._currency != rhs_storage._currency {return false}
        if _storage._payment != rhs_storage._payment {return false}
        if _storage._price != rhs_storage._price {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._quantity != rhs_storage._quantity {return false}
        if _storage._quantityRest != rhs_storage._quantityRest {return false}
        if _storage._figi != rhs_storage._figi {return false}
        if _storage._instrumentType != rhs_storage._instrumentType {return false}
        if _storage._date != rhs_storage._date {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._operationType != rhs_storage._operationType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PortfolioRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PortfolioRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PortfolioRequest, rhs: PortfolioRequest) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PortfolioResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PortfolioResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_amount_shares"),
    2: .standard(proto: "total_amount_bonds"),
    3: .standard(proto: "total_amount_etf"),
    4: .standard(proto: "total_amount_currencies"),
    5: .standard(proto: "total_amount_futures"),
    6: .standard(proto: "expected_yield"),
    7: .same(proto: "positions"),
  ]

  fileprivate class _StorageClass {
    var _totalAmountShares: MoneyValue? = nil
    var _totalAmountBonds: MoneyValue? = nil
    var _totalAmountEtf: MoneyValue? = nil
    var _totalAmountCurrencies: MoneyValue? = nil
    var _totalAmountFutures: MoneyValue? = nil
    var _expectedYield: Quotation? = nil
    var _positions: [PortfolioPosition] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _totalAmountShares = source._totalAmountShares
      _totalAmountBonds = source._totalAmountBonds
      _totalAmountEtf = source._totalAmountEtf
      _totalAmountCurrencies = source._totalAmountCurrencies
      _totalAmountFutures = source._totalAmountFutures
      _expectedYield = source._expectedYield
      _positions = source._positions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._totalAmountShares) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._totalAmountBonds) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._totalAmountEtf) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._totalAmountCurrencies) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._totalAmountFutures) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._expectedYield) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._positions) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._totalAmountShares {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._totalAmountBonds {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._totalAmountEtf {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._totalAmountCurrencies {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._totalAmountFutures {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._expectedYield {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._positions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._positions, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PortfolioResponse, rhs: PortfolioResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._totalAmountShares != rhs_storage._totalAmountShares {return false}
        if _storage._totalAmountBonds != rhs_storage._totalAmountBonds {return false}
        if _storage._totalAmountEtf != rhs_storage._totalAmountEtf {return false}
        if _storage._totalAmountCurrencies != rhs_storage._totalAmountCurrencies {return false}
        if _storage._totalAmountFutures != rhs_storage._totalAmountFutures {return false}
        if _storage._expectedYield != rhs_storage._expectedYield {return false}
        if _storage._positions != rhs_storage._positions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PositionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PositionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PositionsRequest, rhs: PositionsRequest) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PositionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PositionsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "money"),
    2: .same(proto: "blocked"),
    3: .same(proto: "securities"),
    4: .standard(proto: "limits_loading_in_progress"),
    5: .same(proto: "futures"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.money) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.blocked) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.securities) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.limitsLoadingInProgress) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.futures) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.money.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.money, fieldNumber: 1)
    }
    if !self.blocked.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blocked, fieldNumber: 2)
    }
    if !self.securities.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.securities, fieldNumber: 3)
    }
    if self.limitsLoadingInProgress != false {
      try visitor.visitSingularBoolField(value: self.limitsLoadingInProgress, fieldNumber: 4)
    }
    if !self.futures.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.futures, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PositionsResponse, rhs: PositionsResponse) -> Bool {
    if lhs.money != rhs.money {return false}
    if lhs.blocked != rhs.blocked {return false}
    if lhs.securities != rhs.securities {return false}
    if lhs.limitsLoadingInProgress != rhs.limitsLoadingInProgress {return false}
    if lhs.futures != rhs.futures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WithdrawLimitsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WithdrawLimitsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WithdrawLimitsRequest, rhs: WithdrawLimitsRequest) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WithdrawLimitsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WithdrawLimitsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "money"),
    2: .same(proto: "blocked"),
    3: .standard(proto: "blocked_guarantee"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.money) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.blocked) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.blockedGuarantee) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.money.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.money, fieldNumber: 1)
    }
    if !self.blocked.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blocked, fieldNumber: 2)
    }
    if !self.blockedGuarantee.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blockedGuarantee, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WithdrawLimitsResponse, rhs: WithdrawLimitsResponse) -> Bool {
    if lhs.money != rhs.money {return false}
    if lhs.blocked != rhs.blocked {return false}
    if lhs.blockedGuarantee != rhs.blockedGuarantee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PortfolioPosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PortfolioPosition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "instrument_type"),
    3: .same(proto: "quantity"),
    4: .standard(proto: "average_position_price"),
    5: .standard(proto: "expected_yield"),
    6: .standard(proto: "current_nkd"),
    7: .standard(proto: "average_position_price_pt"),
    8: .standard(proto: "current_price"),
    9: .standard(proto: "average_position_price_fifo"),
    10: .standard(proto: "quantity_lots"),
    21: .standard(proto: "blocked"),
  ]

  fileprivate class _StorageClass {
    var _figi: String = String()
    var _instrumentType: String = String()
    var _quantity: Quotation? = nil
    var _averagePositionPrice: MoneyValue? = nil
    var _expectedYield: Quotation? = nil
    var _currentNkd: MoneyValue? = nil
    var _averagePositionPricePt: Quotation? = nil
    var _currentPrice: MoneyValue? = nil
    var _averagePositionPriceFifo: MoneyValue? = nil
    var _quantityLots: Quotation? = nil
    var _blocked: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _figi = source._figi
      _instrumentType = source._instrumentType
      _quantity = source._quantity
      _averagePositionPrice = source._averagePositionPrice
      _expectedYield = source._expectedYield
      _currentNkd = source._currentNkd
      _averagePositionPricePt = source._averagePositionPricePt
      _currentPrice = source._currentPrice
      _averagePositionPriceFifo = source._averagePositionPriceFifo
      _quantityLots = source._quantityLots
      _blocked = source._blocked
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._figi) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._instrumentType) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._quantity) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._averagePositionPrice) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._expectedYield) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._currentNkd) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._averagePositionPricePt) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._currentPrice) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._averagePositionPriceFifo) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._quantityLots) }()
        case 21: try { try decoder.decodeSingularBoolField(value: &_storage._blocked) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._figi.isEmpty {
        try visitor.visitSingularStringField(value: _storage._figi, fieldNumber: 1)
      }
      if !_storage._instrumentType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._instrumentType, fieldNumber: 2)
      }
      try { if let v = _storage._quantity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._averagePositionPrice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._expectedYield {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._currentNkd {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._averagePositionPricePt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._currentPrice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._averagePositionPriceFifo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._quantityLots {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._blocked {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 21)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PortfolioPosition, rhs: PortfolioPosition) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._figi != rhs_storage._figi {return false}
        if _storage._instrumentType != rhs_storage._instrumentType {return false}
        if _storage._quantity != rhs_storage._quantity {return false}
        if _storage._averagePositionPrice != rhs_storage._averagePositionPrice {return false}
        if _storage._expectedYield != rhs_storage._expectedYield {return false}
        if _storage._currentNkd != rhs_storage._currentNkd {return false}
        if _storage._averagePositionPricePt != rhs_storage._averagePositionPricePt {return false}
        if _storage._currentPrice != rhs_storage._currentPrice {return false}
        if _storage._averagePositionPriceFifo != rhs_storage._averagePositionPriceFifo {return false}
        if _storage._quantityLots != rhs_storage._quantityLots {return false}
        if _storage._blocked != rhs_storage._blocked {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PositionsSecurities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PositionsSecurities"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "blocked"),
    3: .same(proto: "balance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.blocked) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.balance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.blocked != 0 {
      try visitor.visitSingularInt64Field(value: self.blocked, fieldNumber: 2)
    }
    if self.balance != 0 {
      try visitor.visitSingularInt64Field(value: self.balance, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PositionsSecurities, rhs: PositionsSecurities) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.blocked != rhs.blocked {return false}
    if lhs.balance != rhs.balance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PositionsFutures: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PositionsFutures"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "blocked"),
    3: .same(proto: "balance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.blocked) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.balance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.blocked != 0 {
      try visitor.visitSingularInt64Field(value: self.blocked, fieldNumber: 2)
    }
    if self.balance != 0 {
      try visitor.visitSingularInt64Field(value: self.balance, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PositionsFutures, rhs: PositionsFutures) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.blocked != rhs.blocked {return false}
    if lhs.balance != rhs.balance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
